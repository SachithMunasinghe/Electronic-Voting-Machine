   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	blinkLED_Buzzer.part.2:
  12               	.LFB46:
  13               		.file 1 "main.c"
   1:main.c        **** #include <avr/io.h>
   2:main.c        **** #include <util/delay.h>
   3:main.c        **** #include <avr/eeprom.h>
   4:main.c        **** #include <string.h>
   5:main.c        **** #include <stdlib.h>
   6:main.c        **** 
   7:main.c        **** // Define LCD I2C address (for example, 0x27, but this might vary)
   8:main.c        **** #define LCD_ADDR 0x27
   9:main.c        **** 
  10:main.c        **** // Pins for the LEDs, debug and Buzzer
  11:main.c        **** #define LED_PIN_Reg PD3  	// LED connected to PD3
  12:main.c        **** #define LED_PIN_Vote PD5 	// LED connected to PD5
  13:main.c        **** #define LED_PIN_RR PD6		// LED connected to PD6
  14:main.c        **** #define Buzzer_PIN PD7		// Buzzer connected to PD7
  15:main.c        **** #define DEBUG_PIN PD4
  16:main.c        **** 
  17:main.c        **** // Pins for buttons
  18:main.c        **** #define Button_PIN_A PC0	// Button for vote A
  19:main.c        **** #define Button_PIN_B PC1	// Button for vote B
  20:main.c        **** #define Button_PIN_C PC2	// Button for vote C
  21:main.c        **** #define Button_PIN_D PC3	// Button for vote D
  22:main.c        **** #define Button_PIN_Reg PB0	// Button for register
  23:main.c        **** #define Button_PIN_St PB1	// Button for start
  24:main.c        **** #define Button_PIN_Result PB6	// Button for result
  25:main.c        **** #define Button_PIN_Reset PB7	// Button for reset
  26:main.c        **** 
  27:main.c        **** #define MAX_LEN 16
  28:main.c        **** #define SCROLL_DELAY 200 // Adjust scroll delay for smoothness
  29:main.c        **** 
  30:main.c        **** // Status codes
  31:main.c        **** #define MI_OK                 0
  32:main.c        **** #define MI_NOTAGERR           1
  33:main.c        **** #define MI_ERR                2
  34:main.c        **** 
  35:main.c        **** // Admin ID (hardcoded)
  36:main.c        **** uint8_t adminID[5] = {0xA3, 0x9B, 0x42, 0x28, 0x52};
  37:main.c        **** 
  38:main.c        **** // EEPROM storage for user IDs and user count
  39:main.c        **** uint8_t userCount EEMEM = 0;  // Stored in EEPROM
  40:main.c        **** uint8_t storedIDs[20][5] EEMEM; // Can store up to 20 IDs
  41:main.c        **** 
  42:main.c        **** // RAM storage for voting status (not using EEPROM)
  43:main.c        **** uint8_t votedUsers[20] = {0};  // 0: not voted, 1: already voted
  44:main.c        **** 
  45:main.c        **** // Vote counters stored in variables
  46:main.c        **** uint8_t voteA = 0;
  47:main.c        **** uint8_t voteB = 0;
  48:main.c        **** uint8_t voteC = 0;
  49:main.c        **** uint8_t voteD = 0;
  50:main.c        **** 
  51:main.c        **** // MFRC522 command set
  52:main.c        **** #define PCD_IDLE              0x00
  53:main.c        **** #define PCD_AUTHENT           0x0E
  54:main.c        **** #define PCD_RECEIVE           0x08
  55:main.c        **** #define PCD_TRANSMIT          0x04
  56:main.c        **** #define PCD_TRANSCEIVE        0x0C
  57:main.c        **** #define PCD_RESETPHASE        0x0F
  58:main.c        **** #define PCD_CALCCRC           0x03
  59:main.c        **** 
  60:main.c        **** // Mifare_One card command set
  61:main.c        **** #define PICC_REQIDL           0x26
  62:main.c        **** #define PICC_REQALL           0x52
  63:main.c        **** #define PICC_ANTICOLL         0x93
  64:main.c        **** 
  65:main.c        **** // MFRC522 registers
  66:main.c        **** #define CommandReg            0x01
  67:main.c        **** #define CommIEnReg            0x02
  68:main.c        **** #define CommIrqReg            0x04
  69:main.c        **** #define ErrorReg              0x06
  70:main.c        **** #define Status1Reg            0x07
  71:main.c        **** #define Status2Reg            0x08
  72:main.c        **** #define FIFODataReg           0x09
  73:main.c        **** #define FIFOLevelReg          0x0A
  74:main.c        **** #define ControlReg            0x0C
  75:main.c        **** #define BitFramingReg         0x0D
  76:main.c        **** #define ModeReg               0x11
  77:main.c        **** #define TxModeReg             0x12
  78:main.c        **** #define RxModeReg             0x13
  79:main.c        **** #define TxControlReg          0x14
  80:main.c        **** #define TxASKReg              0x15
  81:main.c        **** #define TModeReg              0x2A
  82:main.c        **** #define TPrescalerReg         0x2B
  83:main.c        **** #define TReloadRegH           0x2C
  84:main.c        **** #define TReloadRegL           0x2D
  85:main.c        **** 
  86:main.c        **** // Function prototypes
  87:main.c        **** void initSPI(void);
  88:main.c        **** void initButton(void);
  89:main.c        **** void SPI_send(char data);
  90:main.c        **** char SPI_receive(void);
  91:main.c        **** void initLEDs_Buzzer(void);
  92:main.c        **** void blinkLED_Buzzer(uint8_t led_pin);
  93:main.c        **** void LCD_Init(void);
  94:main.c        **** void LCD_SendCommand(uint8_t cmd);
  95:main.c        **** void LCD_SendData(uint8_t data);
  96:main.c        **** void LCD_Print(char *str);
  97:main.c        **** void LCD_ScrollText(const char *str, uint8_t row, uint8_t scrollDist, uint8_t *index);
  98:main.c        **** void LCD_SetPosition(uint8_t row, uint8_t col);
  99:main.c        **** void LCD_Clear(void);
 100:main.c        **** void MFRC522_init(void);
 101:main.c        **** void MFRC522_reset(void);
 102:main.c        **** void MFRC522_write(uint8_t addr, uint8_t val);
 103:main.c        **** uint8_t MFRC522_read(uint8_t addr);
 104:main.c        **** void MFRC522_setBitMask(uint8_t reg, uint8_t mask);
 105:main.c        **** void MFRC522_clearBitMask(uint8_t reg, uint8_t mask);
 106:main.c        **** void MFRC522_antennaOn(void);
 107:main.c        **** uint8_t MFRC522_request(uint8_t reqMode, uint8_t *TagType);
 108:main.c        **** uint8_t MFRC522_toCard(uint8_t command, uint8_t *sendData, uint8_t sendLen, uint8_t *backData, uint
 109:main.c        **** uint8_t MFRC522_anticoll(uint8_t *serNum);
 110:main.c        **** uint8_t isRegistered(uint8_t *serial);
 111:main.c        **** void storeCard(uint8_t *serial);
 112:main.c        **** uint8_t checkAdmin(uint8_t *serial);
 113:main.c        **** uint8_t getUserIndex(uint8_t *serial);
 114:main.c        **** void i2c_init(void);
 115:main.c        **** void i2c_start(uint8_t address);
 116:main.c        **** void i2c_stop(void);
 117:main.c        **** void i2c_write(uint8_t data);
 118:main.c        **** int8_t isButtonPressed(uint8_t button_pin, uint8_t port);
 119:main.c        **** void resetEEPROM(void);  // Function for EEPROM reset
 120:main.c        **** 
 121:main.c        **** int main(void) {
 122:main.c        ****         uint8_t serial[5];
 123:main.c        **** 	uint8_t status;
 124:main.c        ****     	uint8_t str[MAX_LEN];
 125:main.c        ****     	uint8_t scrollIndex = 0;  // Keeps track of the scroll position
 126:main.c        **** 
 127:main.c        ****     	initSPI();
 128:main.c        ****     	initLEDs_Buzzer(); // Initialize both LEDs	
 129:main.c        ****     	MFRC522_init();
 130:main.c        ****     	i2c_init();  // Initialize I2C communication for LCD:
 131:main.c        ****     	LCD_Init();
 132:main.c        ****     	initButton(); 
 133:main.c        ****         blinkLED_Buzzer(LED_PIN_Vote);
 134:main.c        **** 	// Main loop: Scrolling display until register is pressed
 135:main.c        **** initial_state:
 136:main.c        ****     while (1) {
 137:main.c        ****         // Non-blocking scrolling for first line
 138:main.c        ****         LCD_ScrollText("Electronic Voting Machine", 0, 1, &scrollIndex);  // First line scrolls
 139:main.c        ****         LCD_SetPosition(1, 0);  // Fixed message on second line
 140:main.c        ****         LCD_Print("Press register");
 141:main.c        ****         
 142:main.c        ****         // Check for reset button press
 143:main.c        ****         if (isButtonPressed(Button_PIN_Reset, 'B')) {
 144:main.c        ****             blinkLED_Buzzer(LED_PIN_RR);
 145:main.c        ****             LCD_Clear();
 146:main.c        ****             LCD_SetPosition(0, 0);
 147:main.c        ****             LCD_Print("Tap Admin ID");
 148:main.c        **** 
 149:main.c        ****             // Set up a timer for 1 seconds
 150:main.c        ****             uint16_t timeout = 1000 / 10;  // 2000ms, with _delay_ms(10)
 151:main.c        **** 
 152:main.c        ****             while (timeout > 0) {
 153:main.c        ****                 // Actively scan for RFID card
 154:main.c        ****                 status = MFRC522_request(0x26, serial);  // Request RFID card scan
 155:main.c        ****                 if (status == MI_OK && MFRC522_anticoll(serial) == MI_OK) {
 156:main.c        ****                     if (checkAdmin(serial)) {
 157:main.c        ****                         // Admin verified, reset EEPROM
 158:main.c        ****                         LCD_Clear();
 159:main.c        ****                         LCD_SetPosition(0, 0);
 160:main.c        ****                         LCD_Print("Admin Verified");
 161:main.c        ****                         blinkLED_Buzzer(LED_PIN_RR);
 162:main.c        ****                         _delay_ms(50);
 163:main.c        ****                         
 164:main.c        ****                         LCD_Clear();
 165:main.c        ****                         LCD_SetPosition(0, 0);
 166:main.c        ****                         LCD_Print("Please wait");
 167:main.c        ****                         resetEEPROM();  // Clear EEPROM after Admin verification
 168:main.c        ****                         LCD_Clear();
 169:main.c        ****                         LCD_SetPosition(0, 0);
 170:main.c        ****                         LCD_Print("System Reseted");
 171:main.c        ****                         LCD_SetPosition(1, 0);
 172:main.c        ****                         LCD_Print("Successfully");
 173:main.c        ****                         blinkLED_Buzzer(LED_PIN_RR);
 174:main.c        ****                         _delay_ms(50);
 175:main.c        ****                         break;  // Exit loop after reset
 176:main.c        ****                     } else {
 177:main.c        ****                         // Admin authentication failed
 178:main.c        ****                         LCD_Clear();
 179:main.c        ****                         LCD_SetPosition(0, 0);
 180:main.c        ****                         LCD_Print("Auth Failed");
 181:main.c        ****                         blinkLED_Buzzer(LED_PIN_RR);
 182:main.c        ****                         _delay_ms(50);
 183:main.c        ****                         break;  // Exit loop after failed auth
 184:main.c        ****                     }
 185:main.c        ****                 }
 186:main.c        **** 
 187:main.c        ****                 // Reduce the timeout and wait for 10ms between scans
 188:main.c        ****                 _delay_ms(10);
 189:main.c        ****                 timeout--;
 190:main.c        ****             }
 191:main.c        ****         }
 192:main.c        ****         
 193:main.c        ****         // Check for result button press
 194:main.c        ****         if (isButtonPressed(Button_PIN_Result, 'B')) {
 195:main.c        ****             uint8_t totalVoted = voteA + voteB + voteC + voteD;
 196:main.c        ****             if (totalVoted > 0) {
 197:main.c        ****                 // Admin authentication for displaying result
 198:main.c        ****                 blinkLED_Buzzer(LED_PIN_RR);
 199:main.c        ****                 LCD_Clear();
 200:main.c        ****                 LCD_SetPosition(0, 0);
 201:main.c        ****                 LCD_Print("Tap Admin ID");
 202:main.c        **** 
 203:main.c        ****                 // Wait for admin authentication with timeout (0.5 second)
 204:main.c        ****                 uint16_t timeout = 500 / 10;  // 1000ms, with _delay_ms(10)
 205:main.c        ****                 uint8_t adminVerified = 0;
 206:main.c        **** 
 207:main.c        ****                 while (timeout > 0) {
 208:main.c        ****                     status = MFRC522_request(0x26, serial);  // Request RFID card scan
 209:main.c        ****                     if (status == MI_OK && MFRC522_anticoll(serial) == MI_OK) {
 210:main.c        ****                         if (checkAdmin(serial)) {
 211:main.c        ****                             adminVerified = 1;
 212:main.c        ****                             // Admin authenticated, display result
 213:main.c        ****                             blinkLED_Buzzer(LED_PIN_RR);
 214:main.c        **** 
 215:main.c        ****                             // Show the result for 6 seconds (3 alternations of 2 seconds)
 216:main.c        ****                             uint16_t resultDisplayTime = 6000 / 1000; // 6 seconds in 1-second incr
 217:main.c        ****                             while (resultDisplayTime > 0) {
 218:main.c        ****                                 // Display the total votes for 1 second
 219:main.c        ****                                 LCD_Clear();
 220:main.c        ****                                 LCD_SetPosition(0, 0);
 221:main.c        ****                                 char resultMsg1[MAX_LEN];
 222:main.c        ****                                 snprintf(resultMsg1, MAX_LEN, "  A:%d      B:%d", voteA, voteB);
 223:main.c        ****                                 LCD_Print(resultMsg1);
 224:main.c        ****                                 LCD_SetPosition(1, 0);
 225:main.c        ****                                 char resultMsg2[MAX_LEN];
 226:main.c        ****                                 snprintf(resultMsg2, MAX_LEN, "  C:%d      D:%d", voteC, voteD);
 227:main.c        ****                                 LCD_Print(resultMsg2);
 228:main.c        ****                                 _delay_ms(1000);
 229:main.c        **** 
 230:main.c        ****                                 // Display the registered and voted count for 1 second
 231:main.c        ****                                 LCD_Clear();
 232:main.c        ****                                 LCD_SetPosition(0, 0);
 233:main.c        ****                                 char regMsg[MAX_LEN];
 234:main.c        ****                                 snprintf(regMsg, MAX_LEN, "Registered :%d", eeprom_read_byte(&userC
 235:main.c        ****                                 LCD_Print(regMsg);
 236:main.c        ****                                 LCD_SetPosition(1, 0);
 237:main.c        ****                                 char votedMsg[MAX_LEN];
 238:main.c        ****                                 snprintf(votedMsg, MAX_LEN, "Voted :%d", totalVoted);
 239:main.c        ****                                 LCD_Print(votedMsg);
 240:main.c        ****                                 _delay_ms(1000);
 241:main.c        **** 
 242:main.c        ****                                 // Decrement the result display time by 2 seconds (1 second per vie
 243:main.c        ****                                 resultDisplayTime -= 2;
 244:main.c        ****                             }
 245:main.c        ****                             break;
 246:main.c        ****                         }
 247:main.c        ****                     }
 248:main.c        ****                     _delay_ms(10);
 249:main.c        ****                     timeout--;
 250:main.c        ****                 }
 251:main.c        **** 
 252:main.c        ****                 if (!adminVerified) {
 253:main.c        ****                     // Admin authentication failed or timeout
 254:main.c        ****                     LCD_Clear();
 255:main.c        ****                     LCD_SetPosition(0, 0);
 256:main.c        ****                     LCD_Print("Auth Failed");
 257:main.c        ****                     blinkLED_Buzzer(LED_PIN_RR);
 258:main.c        ****                     _delay_ms(50);
 259:main.c        ****                 }
 260:main.c        ****             } else {
 261:main.c        ****                 // No results to display
 262:main.c        ****                 LCD_Clear();
 263:main.c        ****                 LCD_SetPosition(0, 0);
 264:main.c        ****                 LCD_Print("No Results");
 265:main.c        ****                 LCD_SetPosition(1, 0);
 266:main.c        ****                 LCD_Print("To Display");
 267:main.c        ****                 blinkLED_Buzzer(LED_PIN_RR);
 268:main.c        ****                 _delay_ms(100); // Display "No results" message for 2 seconds
 269:main.c        ****             }
 270:main.c        ****         }
 271:main.c        ****         
 272:main.c        ****         // Check for register button press frequently for quick response
 273:main.c        ****         if (isButtonPressed(Button_PIN_Reg, 'B')) {
 274:main.c        ****             blinkLED_Buzzer(LED_PIN_Reg);
 275:main.c        ****             LCD_Clear();  // Clear the screen when registration button is pressed
 276:main.c        ****             // Enter registration mode when register button is pressed
 277:main.c        ****             LCD_SetPosition(0, 0);
 278:main.c        ****             LCD_Print("Tap Admin RFID");
 279:main.c        ****             
 280:main.c        **** 
 281:main.c        ****             while (1) {
 282:main.c        ****                 status = MFRC522_request(0x26, serial);  // Request IDLE cards
 283:main.c        ****                 if (status == MI_OK && MFRC522_anticoll(serial) == MI_OK) {
 284:main.c        ****                     if (checkAdmin(serial)) {
 285:main.c        ****                         blinkLED_Buzzer(LED_PIN_RR);
 286:main.c        ****                         LCD_Clear();
 287:main.c        ****                         LCD_SetPosition(0, 0);
 288:main.c        ****                         LCD_Print("Admin Verified");
 289:main.c        ****                         _delay_ms(100);
 290:main.c        ****                         
 291:main.c        ****                         LCD_Clear();  // Clear the screen for the next message
 292:main.c        ****                         LCD_SetPosition(0, 0);
 293:main.c        ****                         LCD_Print("Registration");
 294:main.c        **** 
 295:main.c        ****                         LCD_SetPosition(1, 0);
 296:main.c        ****                         LCD_Print("Tap your RFID");
 297:main.c        **** 
 298:main.c        ****                         // Registration Mode: Register users
 299:main.c        ****                         while (!isButtonPressed(Button_PIN_St, 'B')) {
 300:main.c        ****                             //LCD_Clear();  // Clear the screen for the next message
 301:main.c        ****                             LCD_SetPosition(0, 0);
 302:main.c        ****                             LCD_Print("Registration");
 303:main.c        ****                             LCD_SetPosition(1, 0);
 304:main.c        ****                             LCD_Print("Tap your RFID");
 305:main.c        ****                             
 306:main.c        ****                             status = MFRC522_request(0x26, serial);
 307:main.c        ****                             if (status == MI_OK && MFRC522_anticoll(serial) == MI_OK) {
 308:main.c        ****                                 if (!isRegistered(serial)) {
 309:main.c        ****                                     storeCard(serial);
 310:main.c        ****                                     LCD_Clear();  // Clear the screen after successful registration
 311:main.c        ****                                     LCD_SetPosition(0, 0);
 312:main.c        ****                                     LCD_Print("Registration");
 313:main.c        ****                                     LCD_SetPosition(1, 0);
 314:main.c        ****                                     LCD_Print("Successful");
 315:main.c        ****                                     blinkLED_Buzzer(LED_PIN_Reg);
 316:main.c        ****                                     _delay_ms(100);
 317:main.c        ****                                 } else {
 318:main.c        ****                                     
 319:main.c        ****                                     LCD_Clear();  // Clear the screen if already registered
 320:main.c        ****                                     LCD_SetPosition(0, 0);
 321:main.c        ****                                     LCD_Print("Already");
 322:main.c        ****                                     LCD_SetPosition(1, 0);
 323:main.c        ****                                     LCD_Print("Registered");
 324:main.c        ****                                     blinkLED_Buzzer(LED_PIN_Reg);
 325:main.c        ****                                     _delay_ms(100);
 326:main.c        ****                         
 327:main.c        ****                                 }
 328:main.c        ****                             }
 329:main.c        ****                         }
 330:main.c        ****                         break;
 331:main.c        ****                     } else {
 332:main.c        ****                         // Admin authentication failed, retry
 333:main.c        ****                         LCD_Clear();  // Clear the screen for retry
 334:main.c        ****                         LCD_SetPosition(0, 0);
 335:main.c        ****                         LCD_Print("Auth Failed");
 336:main.c        ****                         LCD_SetPosition(1, 0);
 337:main.c        ****                         LCD_Print("Try again");
 338:main.c        ****                         blinkLED_Buzzer(LED_PIN_RR);
 339:main.c        ****                         _delay_ms(100);
 340:main.c        ****                         LCD_Clear(); 
 341:main.c        ****                         LCD_SetPosition(0, 0);
 342:main.c        ****                         LCD_Print("Tap Admin RFID");
 343:main.c        ****                     }
 344:main.c        ****                 }
 345:main.c        ****             }
 346:main.c        ****         }
 347:main.c        ****         
 348:main.c        ****         // Check for Start button press
 349:main.c        ****         if (isButtonPressed(Button_PIN_St, 'B')) {
 350:main.c        ****             uint8_t userCountValue = eeprom_read_byte(&userCount); // Get the user count from EEPRO
 351:main.c        ****             if (userCountValue == 0) {
 352:main.c        ****                 // No users registered, display a message and prevent voting
 353:main.c        ****                 blinkLED_Buzzer(LED_PIN_Vote);
 354:main.c        ****                 LCD_Clear();
 355:main.c        ****                 LCD_SetPosition(0, 0);
 356:main.c        ****                 LCD_Print("No Voters");
 357:main.c        ****                 LCD_SetPosition(1, 0);
 358:main.c        ****                 LCD_Print("Register first");
 359:main.c        ****                 _delay_ms(100);  // Show the message for 0.1 seconds
 360:main.c        ****                 continue;  // Return to the main loop
 361:main.c        ****             }
 362:main.c        ****             blinkLED_Buzzer(LED_PIN_RR);
 363:main.c        ****             LCD_Clear();  // Clear the screen when start button is pressed
 364:main.c        **** 
 365:main.c        ****             // Admin authentication before starting voting
 366:main.c        ****             LCD_SetPosition(0, 0);
 367:main.c        ****             LCD_Print("Tap Admin ID");
 368:main.c        **** 
 369:main.c        ****             while (1) {
 370:main.c        ****                 status = MFRC522_request(0x26, serial);  // Request card scan
 371:main.c        ****                 if (status == MI_OK && MFRC522_anticoll(serial) == MI_OK) {
 372:main.c        ****                     if (checkAdmin(serial)) {
 373:main.c        ****                         blinkLED_Buzzer(LED_PIN_RR);
 374:main.c        ****                         LCD_Clear();  // Clear the screen after successful admin authentication
 375:main.c        ****                         LCD_SetPosition(0, 0);
 376:main.c        ****                         LCD_Print("Admin Verified");
 377:main.c        ****                         _delay_ms(100);  // Give some time to show verification message
 378:main.c        ****                         break;  // Break to start voting after admin check
 379:main.c        ****                     } else {
 380:main.c        ****                         // Admin authentication failed, retry
 381:main.c        ****                         LCD_Clear();  // Clear the screen for retry
 382:main.c        ****                         LCD_SetPosition(0, 0);
 383:main.c        ****                         LCD_Print("Auth Failed");
 384:main.c        ****                         _delay_ms(100);
 385:main.c        ****                         LCD_Clear(); 
 386:main.c        ****                         LCD_SetPosition(0, 0);
 387:main.c        ****                         LCD_Print("Tap Admin ID");
 388:main.c        ****                     }
 389:main.c        ****                 }
 390:main.c        ****             }
 391:main.c        ****             // Voting mode begins here
 392:main.c        ****             LCD_Clear();
 393:main.c        ****             LCD_SetPosition(0, 0);
 394:main.c        ****             LCD_Print("Tap your RFID");
 395:main.c        ****             LCD_SetPosition(1, 0);
 396:main.c        ****             LCD_Print("To Vote");
 397:main.c        ****             
 398:main.c        ****             while (1) {
 399:main.c        ****                 status = MFRC522_request(0x26, serial);  // Request RFID scan for user
 400:main.c        ****                 if (status == MI_OK && MFRC522_anticoll(serial) == MI_OK) {
 401:main.c        ****                     uint8_t userIndex = getUserIndex(serial);  // Find the user in registered IDs
 402:main.c        ****                     if (userIndex != 255) {  // User is registered
 403:main.c        ****                         if (votedUsers[userIndex] == 0) {  // Check if the user has not voted
 404:main.c        ****                             LCD_Clear();
 405:main.c        ****                             LCD_SetPosition(0, 0);
 406:main.c        ****                             LCD_Print("Please vote");
 407:main.c        ****                             blinkLED_Buzzer(LED_PIN_Reg);
 408:main.c        ****                             
 409:main.c        ****                             while (1) {
 410:main.c        ****                                 if (isButtonPressed(Button_PIN_A, 'C')) {
 411:main.c        ****                                     voteA++;
 412:main.c        ****                                     blinkLED_Buzzer(LED_PIN_Vote);
 413:main.c        ****                                     LCD_Clear();
 414:main.c        ****                                     LCD_SetPosition(0, 0);
 415:main.c        ****                                     LCD_Print("Thank for voting");
 416:main.c        ****                                     votedUsers[userIndex] = 1;  // Mark the user as having voted
 417:main.c        ****                                     _delay_ms(100);
 418:main.c        ****                                     LCD_Clear();
 419:main.c        ****                                     LCD_SetPosition(0, 0);
 420:main.c        ****                                     LCD_Print("Tap your RFID");
 421:main.c        ****                                     LCD_SetPosition(1, 0);
 422:main.c        ****                                     LCD_Print("To Vote");
 423:main.c        ****                                     break;
 424:main.c        ****                                     
 425:main.c        ****                                 } else if (isButtonPressed(Button_PIN_B, 'C')) {
 426:main.c        ****                                     voteB++;
 427:main.c        ****                                     blinkLED_Buzzer(LED_PIN_Vote);
 428:main.c        ****                                     LCD_Clear();
 429:main.c        ****                                     LCD_SetPosition(0, 0);
 430:main.c        ****                                     LCD_Print("Thank for voting");
 431:main.c        ****                                     votedUsers[userIndex] = 1;  // Mark the user as having voted
 432:main.c        ****                                     _delay_ms(100);
 433:main.c        ****                                     LCD_Clear();
 434:main.c        ****                                     LCD_SetPosition(0, 0);
 435:main.c        ****                                     LCD_Print("Tap your RFID");
 436:main.c        ****                                     LCD_SetPosition(1, 0);
 437:main.c        ****                                     LCD_Print("To Vote");
 438:main.c        ****                                     break;
 439:main.c        ****                                     
 440:main.c        ****                                 } else if (isButtonPressed(Button_PIN_C, 'C')) {
 441:main.c        ****                                     voteC++;
 442:main.c        ****                                     blinkLED_Buzzer(LED_PIN_Vote);
 443:main.c        ****                                     LCD_Clear();
 444:main.c        ****                                     LCD_SetPosition(0, 0);
 445:main.c        ****                                     LCD_Print("Thank for voting");
 446:main.c        ****                                     votedUsers[userIndex] = 1;  // Mark the user as having voted
 447:main.c        ****                                     _delay_ms(100);
 448:main.c        ****                                     LCD_Clear();
 449:main.c        ****                                     LCD_SetPosition(0, 0);
 450:main.c        ****                                     LCD_Print("Tap your RFID");
 451:main.c        ****                                     LCD_SetPosition(1, 0);
 452:main.c        ****                                     LCD_Print("To Vote");
 453:main.c        ****                                     break;
 454:main.c        ****                                     
 455:main.c        ****                                 } else if (isButtonPressed(Button_PIN_D, 'C')) {
 456:main.c        ****                                     voteD++;
 457:main.c        ****                                     blinkLED_Buzzer(LED_PIN_Vote);
 458:main.c        ****                                     LCD_Clear();
 459:main.c        ****                                     LCD_SetPosition(0, 0);
 460:main.c        ****                                     LCD_Print("Thank for voting");
 461:main.c        ****                                     votedUsers[userIndex] = 1;  // Mark the user as having voted
 462:main.c        ****                                     _delay_ms(100);
 463:main.c        ****                                     LCD_Clear();
 464:main.c        ****                                     LCD_SetPosition(0, 0);
 465:main.c        ****                                     LCD_Print("Tap your RFID");
 466:main.c        ****                                     LCD_SetPosition(1, 0);
 467:main.c        ****                                     LCD_Print("To Vote");
 468:main.c        ****                                     break;
 469:main.c        ****                                 }
 470:main.c        ****                             }
 471:main.c        ****                         } else {
 472:main.c        ****                             LCD_Clear();
 473:main.c        ****                             LCD_SetPosition(0, 0);
 474:main.c        ****                             LCD_Print("Already voted");
 475:main.c        ****                             blinkLED_Buzzer(LED_PIN_Reg);
 476:main.c        ****                             _delay_ms(100);
 477:main.c        ****                             
 478:main.c        ****                             LCD_Clear();
 479:main.c        ****                             LCD_SetPosition(0, 0);
 480:main.c        ****                             LCD_Print("Tap your RFID");
 481:main.c        ****                             LCD_SetPosition(1, 0);
 482:main.c        ****                             LCD_Print("To Vote");
 483:main.c        ****                         }
 484:main.c        ****                     } else {
 485:main.c        ****                         LCD_Clear();
 486:main.c        ****                         LCD_SetPosition(0, 0);
 487:main.c        ****                         LCD_Print("Invalid Vote");
 488:main.c        ****                         blinkLED_Buzzer(LED_PIN_Reg);
 489:main.c        ****                         _delay_ms(100);
 490:main.c        ****                         
 491:main.c        ****                         LCD_Clear();
 492:main.c        ****                         LCD_SetPosition(0, 0);
 493:main.c        ****                         LCD_Print("Tap your RFID");
 494:main.c        ****                         LCD_SetPosition(1, 0);
 495:main.c        ****                         LCD_Print("To Vote");
 496:main.c        ****                     }
 497:main.c        ****                 }
 498:main.c        **** 
 499:main.c        ****                 // Check for Result button press
 500:main.c        ****                 if (isButtonPressed(Button_PIN_Result, 'B')) {
 501:main.c        ****                     LCD_Clear();
 502:main.c        ****                     LCD_SetPosition(0, 0);
 503:main.c        ****                     LCD_Print("Tap Admin ID");
 504:main.c        **** 
 505:main.c        ****                     // Wait for admin authentication with timeout (0.5 second)
 506:main.c        ****                     uint16_t timeout = 500 / 10;  // 1000ms, with _delay_ms(10)
 507:main.c        ****                     uint8_t adminVerified = 0;
 508:main.c        **** 
 509:main.c        ****                     while (timeout > 0) {
 510:main.c        ****                         status = MFRC522_request(0x26, serial);  // Request RFID card scan
 511:main.c        ****                         if (status == MI_OK && MFRC522_anticoll(serial) == MI_OK) {
 512:main.c        ****                             if (checkAdmin(serial)) {
 513:main.c        ****                                 adminVerified = 1;
 514:main.c        ****                                 // Admin authenticated, display result
 515:main.c        ****                                 blinkLED_Buzzer(LED_PIN_RR);
 516:main.c        ****                                 uint8_t totalVoted = voteA + voteB + voteC + voteD;
 517:main.c        ****                                 uint8_t userNum = eeprom_read_byte(&userCount);
 518:main.c        ****                                 
 519:main.c        ****                                 // Show the result for 6 seconds (3 alternations of 2 seconds)
 520:main.c        ****                                 uint16_t resultDisplayTime = 6000 / 1000; // 6 seconds in 1-second 
 521:main.c        ****                                 while (resultDisplayTime > 0) {
 522:main.c        ****                                     // Display the total votes for 1 second
 523:main.c        ****                                     LCD_Clear();
 524:main.c        ****                                     LCD_SetPosition(0, 0);
 525:main.c        ****                                     char resultMsg1[MAX_LEN];
 526:main.c        ****                                     snprintf(resultMsg1, MAX_LEN, "  A:%d      B:%d", voteA, voteB)
 527:main.c        ****                                     LCD_Print(resultMsg1);
 528:main.c        ****                                     LCD_SetPosition(1, 0);
 529:main.c        ****                                     char resultMsg2[MAX_LEN];
 530:main.c        ****                                     snprintf(resultMsg2, MAX_LEN, "  C:%d      D:%d", voteC, voteD)
 531:main.c        ****                                     LCD_Print(resultMsg2);
 532:main.c        ****                                     _delay_ms(1000);
 533:main.c        **** 
 534:main.c        ****                                     // Display the registered and voted count for 1 second
 535:main.c        ****                                     LCD_Clear();
 536:main.c        ****                                     LCD_SetPosition(0, 0);
 537:main.c        ****                                     char regMsg[MAX_LEN];
 538:main.c        ****                                     snprintf(regMsg, MAX_LEN, "Registered :%d", userNum);
 539:main.c        ****                                     LCD_Print(regMsg);
 540:main.c        ****                                     LCD_SetPosition(1, 0);
 541:main.c        ****                                     char votedMsg[MAX_LEN];
 542:main.c        ****                                     snprintf(votedMsg, MAX_LEN, "Voted :%d", totalVoted);
 543:main.c        ****                                     LCD_Print(votedMsg);
 544:main.c        ****                                     _delay_ms(1000);
 545:main.c        **** 
 546:main.c        ****                                     // Decrement the result display time by 2 seconds (1 second per
 547:main.c        ****                                     resultDisplayTime -= 2;
 548:main.c        ****                                     
 549:main.c        ****                                 }
 550:main.c        ****                                 // After showing the result, return to the initial state (registrat
 551:main.c        ****                                 goto initial_state;
 552:main.c        ****                             } else {
 553:main.c        ****                                 // Admin authentication failed
 554:main.c        ****                                 LCD_Clear();
 555:main.c        ****                                 LCD_SetPosition(0, 0);
 556:main.c        ****                                 LCD_Print("Auth Failed");
 557:main.c        ****                                 blinkLED_Buzzer(LED_PIN_RR);
 558:main.c        ****                                 _delay_ms(50);
 559:main.c        ****                                 break;  // Exit loop after failed auth
 560:main.c        ****                             }
 561:main.c        ****                         }
 562:main.c        **** 
 563:main.c        ****                         // Reduce the timeout and wait for 10ms between scans
 564:main.c        ****                         _delay_ms(10);
 565:main.c        ****                         timeout--;
 566:main.c        ****                     }
 567:main.c        **** 
 568:main.c        ****                     if (!adminVerified) {
 569:main.c        ****                         // Admin authentication failed or timeout
 570:main.c        ****                         LCD_Clear();
 571:main.c        ****                         LCD_SetPosition(0, 0);
 572:main.c        ****                         LCD_Print("Tap your RFID");
 573:main.c        ****                         LCD_SetPosition(1, 0);
 574:main.c        ****                         LCD_Print("To Vote");
 575:main.c        ****                     }
 576:main.c        ****                 }
 577:main.c        ****             }
 578:main.c        ****         }
 579:main.c        **** 
 580:main.c        ****         _delay_ms(SCROLL_DELAY); // Added delay to reduce processing overhead and enable smooth scr
 581:main.c        ****     }
 582:main.c        **** }
 583:main.c        **** 
 584:main.c        **** // Function to initialize buttons with internal pull-up resistors
 585:main.c        **** void initButton(void) {
 586:main.c        ****     // Set buttons connected to PORTC (A, B, C, D) as input with pull-up
 587:main.c        ****     DDRC &= ~((1 << Button_PIN_A) | (1 << Button_PIN_B) | (1 << Button_PIN_C) | (1 << Button_PIN_D)
 588:main.c        ****     PORTC |= (1 << Button_PIN_A) | (1 << Button_PIN_B) | (1 << Button_PIN_C) | (1 << Button_PIN_D);
 589:main.c        **** 
 590:main.c        ****     // Set buttons connected to PORTB (Register, Start, Result, Reset) as input with pull-up
 591:main.c        ****     DDRB &= ~((1 << Button_PIN_Reg) | (1 << Button_PIN_St) | (1 << Button_PIN_Result) | (1 << Butto
 592:main.c        ****     PORTB |= (1 << Button_PIN_Reg) | (1 << Button_PIN_St) | (1 << Button_PIN_Result) | (1 << Button
 593:main.c        **** }
 594:main.c        **** 
 595:main.c        **** void initSPI(void) {
 596:main.c        ****     DDRB = (1<<PB3) | (1<<PB5) | (1<<PB2);
 597:main.c        ****     SPCR = (1<<SPE) | (1<<MSTR) | (1<<SPR0);
 598:main.c        **** }
 599:main.c        **** 
 600:main.c        **** void SPI_send(char data) {
 601:main.c        ****     SPDR = data;
 602:main.c        ****     while(!(SPSR & (1<<SPIF)));
 603:main.c        **** }
 604:main.c        **** 
 605:main.c        **** char SPI_receive(void) {
 606:main.c        ****     SPI_send(0x00);
 607:main.c        ****     while(!(SPSR & (1<<SPIF)));
 608:main.c        ****     return SPDR;
 609:main.c        **** }
 610:main.c        **** 
 611:main.c        **** void MFRC522_init(void) {
 612:main.c        ****     MFRC522_reset();
 613:main.c        ****     MFRC522_write(TModeReg, 0x8D);
 614:main.c        ****     MFRC522_write(TPrescalerReg, 0x3E);
 615:main.c        ****     MFRC522_write(TReloadRegL, 30);
 616:main.c        ****     MFRC522_write(TReloadRegH, 0);
 617:main.c        ****     MFRC522_write(TxASKReg, 0x40);
 618:main.c        ****     MFRC522_write(ModeReg, 0x3D);
 619:main.c        ****     MFRC522_antennaOn();
 620:main.c        **** }
 621:main.c        **** 
 622:main.c        **** void MFRC522_reset(void) {
 623:main.c        ****     MFRC522_write(CommandReg, PCD_RESETPHASE);
 624:main.c        **** }
 625:main.c        **** 
 626:main.c        **** void MFRC522_write(uint8_t addr, uint8_t val) {
 627:main.c        ****     PORTB &= ~(1<<PB2);
 628:main.c        ****     SPI_send((addr<<1)&0x7E);
 629:main.c        ****     SPI_send(val);
 630:main.c        ****     PORTB |= (1<<PB2);
 631:main.c        **** }
 632:main.c        **** 
 633:main.c        **** uint8_t MFRC522_read(uint8_t addr) {
 634:main.c        ****     uint8_t val;
 635:main.c        ****     PORTB &= ~(1<<PB2);
 636:main.c        ****     SPI_send(((addr<<1)&0x7E) | 0x80);
 637:main.c        ****     val = SPI_receive();
 638:main.c        ****     PORTB |= (1<<PB2);
 639:main.c        ****     return val;
 640:main.c        **** }
 641:main.c        **** 
 642:main.c        **** void MFRC522_setBitMask(uint8_t reg, uint8_t mask) {
 643:main.c        ****     uint8_t tmp = MFRC522_read(reg);
 644:main.c        ****     MFRC522_write(reg, tmp | mask);
 645:main.c        **** }
 646:main.c        **** 
 647:main.c        **** void MFRC522_clearBitMask(uint8_t reg, uint8_t mask) {
 648:main.c        ****     uint8_t tmp = MFRC522_read(reg);
 649:main.c        ****     MFRC522_write(reg, tmp & (~mask));
 650:main.c        **** }
 651:main.c        **** 
 652:main.c        **** void MFRC522_antennaOn(void) {
 653:main.c        ****     uint8_t temp = MFRC522_read(TxControlReg);
 654:main.c        ****     if (!(temp & 0x03)) {
 655:main.c        ****         MFRC522_setBitMask(TxControlReg, 0x03);
 656:main.c        ****     }
 657:main.c        **** }
 658:main.c        **** 
 659:main.c        **** uint8_t MFRC522_request(uint8_t reqMode, uint8_t *TagType) {
 660:main.c        ****     uint8_t status;
 661:main.c        ****     uint8_t backBits;
 662:main.c        **** 
 663:main.c        ****     MFRC522_write(BitFramingReg, 0x07);
 664:main.c        ****     TagType[0] = reqMode;
 665:main.c        ****     status = MFRC522_toCard(PCD_TRANSCEIVE, TagType, 1, TagType, &backBits);
 666:main.c        **** 
 667:main.c        ****     if ((status != MI_OK) || (backBits != 0x10)) {
 668:main.c        ****         status = MI_ERR;
 669:main.c        ****     }
 670:main.c        **** 
 671:main.c        ****     return status;
 672:main.c        **** }
 673:main.c        **** 
 674:main.c        **** uint8_t MFRC522_toCard(uint8_t command, uint8_t *sendData, uint8_t sendLen, uint8_t *backData, uint
 675:main.c        ****     uint8_t status = MI_ERR;
 676:main.c        ****     uint8_t irqEn = 0x00;
 677:main.c        ****     uint8_t waitIRq = 0x00;
 678:main.c        ****     uint8_t lastBits;
 679:main.c        ****     uint8_t n;
 680:main.c        ****     uint8_t i;
 681:main.c        **** 
 682:main.c        ****     switch (command) {
 683:main.c        ****         case PCD_AUTHENT:
 684:main.c        ****             irqEn = 0x12;
 685:main.c        ****             waitIRq = 0x10;
 686:main.c        ****             break;
 687:main.c        ****         case PCD_TRANSCEIVE:
 688:main.c        ****             irqEn = 0x77;
 689:main.c        ****             waitIRq = 0x30;
 690:main.c        ****             break;
 691:main.c        ****         default:
 692:main.c        ****             break;
 693:main.c        ****     }
 694:main.c        **** 
 695:main.c        ****     MFRC522_write(CommIEnReg, irqEn | 0x80);
 696:main.c        ****     MFRC522_clearBitMask(CommIrqReg, 0x80);
 697:main.c        ****     MFRC522_setBitMask(FIFOLevelReg, 0x80);
 698:main.c        **** 
 699:main.c        ****     MFRC522_write(CommandReg, PCD_IDLE);
 700:main.c        **** 
 701:main.c        ****     for (i = 0; i < sendLen; i++) {
 702:main.c        ****         MFRC522_write(FIFODataReg, sendData[i]);
 703:main.c        ****     }
 704:main.c        **** 
 705:main.c        ****     MFRC522_write(CommandReg, command);
 706:main.c        ****     if (command == PCD_TRANSCEIVE) {
 707:main.c        ****         MFRC522_setBitMask(BitFramingReg, 0x80);
 708:main.c        ****     }
 709:main.c        **** 
 710:main.c        ****     i = 2000;
 711:main.c        ****     do {
 712:main.c        ****         n = MFRC522_read(CommIrqReg);
 713:main.c        ****         i--;
 714:main.c        ****     } while ((i != 0) && !(n & 0x01) && !(n & waitIRq));
 715:main.c        **** 
 716:main.c        ****     MFRC522_clearBitMask(BitFramingReg, 0x80);
 717:main.c        **** 
 718:main.c        ****     if (i != 0) {
 719:main.c        ****         if (!(MFRC522_read(ErrorReg) & 0x1B)) {
 720:main.c        ****             status = MI_OK;
 721:main.c        ****             if (n & irqEn & 0x01) {
 722:main.c        ****                 status = MI_NOTAGERR;
 723:main.c        ****             }
 724:main.c        **** 
 725:main.c        ****             if (command == PCD_TRANSCEIVE) {
 726:main.c        ****                 n = MFRC522_read(FIFOLevelReg);
 727:main.c        ****                 lastBits = MFRC522_read(ControlReg) & 0x07;
 728:main.c        ****                 if (lastBits) {
 729:main.c        ****                     *backLen = (n - 1) * 8 + lastBits;
 730:main.c        ****                 } else {
 731:main.c        ****                     *backLen = n * 8;
 732:main.c        ****                 }
 733:main.c        **** 
 734:main.c        ****                 if (n == 0) {
 735:main.c        ****                     n = 1;
 736:main.c        ****                 }
 737:main.c        ****                 if (n > MAX_LEN) {
 738:main.c        ****                     n = MAX_LEN;
 739:main.c        ****                 }
 740:main.c        **** 
 741:main.c        ****                 for (i = 0; i < n; i++) {
 742:main.c        ****                     backData[i] = MFRC522_read(FIFODataReg);
 743:main.c        ****                 }
 744:main.c        ****             }
 745:main.c        ****         } else {
 746:main.c        ****             status = MI_ERR;
 747:main.c        ****         }
 748:main.c        ****     }
 749:main.c        **** 
 750:main.c        ****     return status;
 751:main.c        **** }
 752:main.c        **** 
 753:main.c        **** uint8_t MFRC522_anticoll(uint8_t *serNum) {
 754:main.c        ****     uint8_t status;
 755:main.c        ****     uint8_t i;
 756:main.c        ****     uint8_t serNumCheck = 0;
 757:main.c        ****     uint8_t unLen;
 758:main.c        **** 
 759:main.c        ****     MFRC522_write(BitFramingReg, 0x00);
 760:main.c        ****     serNum[0] = PICC_ANTICOLL;
 761:main.c        ****     serNum[1] = 0x20;
 762:main.c        ****     status = MFRC522_toCard(PCD_TRANSCEIVE, serNum, 2, serNum, &unLen);
 763:main.c        **** 
 764:main.c        ****     if (status == MI_OK) {
 765:main.c        ****         for (i = 0; i < 4; i++) {
 766:main.c        ****             serNumCheck ^= serNum[i];
 767:main.c        ****         }
 768:main.c        ****         if (serNumCheck != serNum[i]) {
 769:main.c        ****             status = MI_ERR;
 770:main.c        ****         }
 771:main.c        ****     }
 772:main.c        **** 
 773:main.c        ****     return status;
 774:main.c        **** }
 775:main.c        **** 
 776:main.c        **** void initLEDs_Buzzer(void) {
 777:main.c        ****     	// Initialize both LEDs and the buzzer
 778:main.c        **** 	DDRD |= (1<<LED_PIN_Reg) | (1<<LED_PIN_Vote) | (1<<LED_PIN_RR) | (1<<Buzzer_PIN);
 779:main.c        **** }
 780:main.c        **** 
 781:main.c        **** void blinkLED_Buzzer(uint8_t led_pin) {
  14               		.loc 1 781 0
  15               		.cfi_startproc
  16               	/* prologue: function */
  17               	/* frame size = 0 */
  18               	/* stack size = 0 */
  19               	.L__stack_usage = 0
  20               	.LVL0:
 782:main.c        ****     // Blink the specified LED
 783:main.c        **** 	if (led_pin == LED_PIN_Reg) {
 784:main.c        ****         	PORTD |= (1<<led_pin);
 785:main.c        **** 		PORTD |= (1<<Buzzer_PIN);
 786:main.c        ****         	_delay_ms(50);         
 787:main.c        ****         	PORTD &= ~(1<<led_pin);
 788:main.c        **** 		PORTD &= ~(1<<Buzzer_PIN);
 789:main.c        **** 
 790:main.c        ****     	} else if (led_pin == LED_PIN_Vote) {
 791:main.c        ****         	PORTD |= (1<<led_pin);
 792:main.c        **** 		PORTD |= (1<<Buzzer_PIN);
 793:main.c        ****         	_delay_ms(50);         
 794:main.c        ****         	PORTD &= ~(1<<led_pin);
 795:main.c        **** 		PORTD &= ~(1<<Buzzer_PIN);
 796:main.c        **** 
 797:main.c        ****     	}else if (led_pin == LED_PIN_RR) {
 798:main.c        **** 		PORTD |= (1<<led_pin);
  21               		.loc 1 798 0
  22 0000 5E9A      		sbi 0xb,6
 799:main.c        **** 		PORTD |= (1<<Buzzer_PIN);
  23               		.loc 1 799 0
  24 0002 5F9A      		sbi 0xb,7
  25               	.LVL1:
  26               	.LBB401:
  27               	.LBB402:
  28               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  29               		.loc 2 187 0
  30 0004 2FEF      		ldi r18,lo8(159999)
  31 0006 80E7      		ldi r24,hi8(159999)
  32 0008 92E0      		ldi r25,hlo8(159999)
  33 000a 2150      	1:	subi r18,1
  34 000c 8040      		sbci r24,0
  35 000e 9040      		sbci r25,0
  36 0010 01F4      		brne 1b
  37 0012 00C0      		rjmp .
  38 0014 0000      		nop
  39               	.LVL2:
  40               	.LBE402:
  41               	.LBE401:
 800:main.c        **** 		_delay_ms(50);
 801:main.c        **** 		PORTD &= ~(1<<led_pin);
  42               		.loc 1 801 0
  43 0016 5E98      		cbi 0xb,6
 802:main.c        **** 		PORTD &= ~(1<<Buzzer_PIN);
  44               		.loc 1 802 0
  45 0018 5F98      		cbi 0xb,7
  46               	/* epilogue start */
 803:main.c        **** 	}
 804:main.c        **** }
  47               		.loc 1 804 0
  48 001a 0895      		ret
  49               		.cfi_endproc
  50               	.LFE46:
  52               	.global	initButton
  54               	initButton:
  55               	.LFB11:
 585:main.c        ****     // Set buttons connected to PORTC (A, B, C, D) as input with pull-up
  56               		.loc 1 585 0
  57               		.cfi_startproc
  58               	/* prologue: function */
  59               	/* frame size = 0 */
  60               	/* stack size = 0 */
  61               	.L__stack_usage = 0
 587:main.c        ****     PORTC |= (1 << Button_PIN_A) | (1 << Button_PIN_B) | (1 << Button_PIN_C) | (1 << Button_PIN_D);
  62               		.loc 1 587 0
  63 001c 87B1      		in r24,0x7
  64 001e 807F      		andi r24,lo8(-16)
  65 0020 87B9      		out 0x7,r24
 588:main.c        **** 
  66               		.loc 1 588 0
  67 0022 88B1      		in r24,0x8
  68 0024 8F60      		ori r24,lo8(15)
  69 0026 88B9      		out 0x8,r24
 591:main.c        ****     PORTB |= (1 << Button_PIN_Reg) | (1 << Button_PIN_St) | (1 << Button_PIN_Result) | (1 << Button
  70               		.loc 1 591 0
  71 0028 84B1      		in r24,0x4
  72 002a 8C73      		andi r24,lo8(60)
  73 002c 84B9      		out 0x4,r24
 592:main.c        **** }
  74               		.loc 1 592 0
  75 002e 85B1      		in r24,0x5
  76 0030 836C      		ori r24,lo8(-61)
  77 0032 85B9      		out 0x5,r24
  78               	/* epilogue start */
 593:main.c        **** 
  79               		.loc 1 593 0
  80 0034 0895      		ret
  81               		.cfi_endproc
  82               	.LFE11:
  84               	.global	initSPI
  86               	initSPI:
  87               	.LFB12:
 595:main.c        ****     DDRB = (1<<PB3) | (1<<PB5) | (1<<PB2);
  88               		.loc 1 595 0
  89               		.cfi_startproc
  90               	/* prologue: function */
  91               	/* frame size = 0 */
  92               	/* stack size = 0 */
  93               	.L__stack_usage = 0
 596:main.c        ****     SPCR = (1<<SPE) | (1<<MSTR) | (1<<SPR0);
  94               		.loc 1 596 0
  95 0036 8CE2      		ldi r24,lo8(44)
  96 0038 84B9      		out 0x4,r24
 597:main.c        **** }
  97               		.loc 1 597 0
  98 003a 81E5      		ldi r24,lo8(81)
  99 003c 8CBD      		out 0x2c,r24
 100               	/* epilogue start */
 598:main.c        **** 
 101               		.loc 1 598 0
 102 003e 0895      		ret
 103               		.cfi_endproc
 104               	.LFE12:
 106               	.global	SPI_send
 108               	SPI_send:
 109               	.LFB13:
 600:main.c        ****     SPDR = data;
 110               		.loc 1 600 0
 111               		.cfi_startproc
 112               	.LVL3:
 113               	/* prologue: function */
 114               	/* frame size = 0 */
 115               	/* stack size = 0 */
 116               	.L__stack_usage = 0
 601:main.c        ****     while(!(SPSR & (1<<SPIF)));
 117               		.loc 1 601 0
 118 0040 8EBD      		out 0x2e,r24
 119               	.L5:
 602:main.c        **** }
 120               		.loc 1 602 0 discriminator 1
 121 0042 0DB4      		in __tmp_reg__,0x2d
 122 0044 07FE      		sbrs __tmp_reg__,7
 123 0046 00C0      		rjmp .L5
 124               	/* epilogue start */
 603:main.c        **** 
 125               		.loc 1 603 0
 126 0048 0895      		ret
 127               		.cfi_endproc
 128               	.LFE13:
 130               	.global	SPI_receive
 132               	SPI_receive:
 133               	.LFB14:
 605:main.c        ****     SPI_send(0x00);
 134               		.loc 1 605 0
 135               		.cfi_startproc
 136               	/* prologue: function */
 137               	/* frame size = 0 */
 138               	/* stack size = 0 */
 139               	.L__stack_usage = 0
 606:main.c        ****     while(!(SPSR & (1<<SPIF)));
 140               		.loc 1 606 0
 141 004a 80E0      		ldi r24,0
 142 004c 0E94 0000 		call SPI_send
 143               	.LVL4:
 144               	.L8:
 607:main.c        ****     return SPDR;
 145               		.loc 1 607 0 discriminator 1
 146 0050 0DB4      		in __tmp_reg__,0x2d
 147 0052 07FE      		sbrs __tmp_reg__,7
 148 0054 00C0      		rjmp .L8
 608:main.c        **** }
 149               		.loc 1 608 0
 150 0056 8EB5      		in r24,0x2e
 151               	/* epilogue start */
 609:main.c        **** 
 152               		.loc 1 609 0
 153 0058 0895      		ret
 154               		.cfi_endproc
 155               	.LFE14:
 157               	.global	MFRC522_write
 159               	MFRC522_write:
 160               	.LFB17:
 626:main.c        ****     PORTB &= ~(1<<PB2);
 161               		.loc 1 626 0
 162               		.cfi_startproc
 163               	.LVL5:
 164 005a CF93      		push r28
 165               	.LCFI0:
 166               		.cfi_def_cfa_offset 3
 167               		.cfi_offset 28, -2
 168               	/* prologue: function */
 169               	/* frame size = 0 */
 170               	/* stack size = 1 */
 171               	.L__stack_usage = 1
 172 005c C62F      		mov r28,r22
 627:main.c        ****     SPI_send((addr<<1)&0x7E);
 173               		.loc 1 627 0
 174 005e 2A98      		cbi 0x5,2
 628:main.c        ****     SPI_send(val);
 175               		.loc 1 628 0
 176 0060 880F      		lsl r24
 177               	.LVL6:
 178 0062 8E77      		andi r24,lo8(126)
 179 0064 0E94 0000 		call SPI_send
 180               	.LVL7:
 629:main.c        ****     PORTB |= (1<<PB2);
 181               		.loc 1 629 0
 182 0068 8C2F      		mov r24,r28
 183 006a 0E94 0000 		call SPI_send
 184               	.LVL8:
 630:main.c        **** }
 185               		.loc 1 630 0
 186 006e 2A9A      		sbi 0x5,2
 187               	/* epilogue start */
 631:main.c        **** 
 188               		.loc 1 631 0
 189 0070 CF91      		pop r28
 190               	.LVL9:
 191 0072 0895      		ret
 192               		.cfi_endproc
 193               	.LFE17:
 195               	.global	MFRC522_reset
 197               	MFRC522_reset:
 198               	.LFB16:
 622:main.c        ****     MFRC522_write(CommandReg, PCD_RESETPHASE);
 199               		.loc 1 622 0
 200               		.cfi_startproc
 201               	/* prologue: function */
 202               	/* frame size = 0 */
 203               	/* stack size = 0 */
 204               	.L__stack_usage = 0
 623:main.c        **** }
 205               		.loc 1 623 0
 206 0074 6FE0      		ldi r22,lo8(15)
 207 0076 81E0      		ldi r24,lo8(1)
 208 0078 0C94 0000 		jmp MFRC522_write
 209               	.LVL10:
 210               		.cfi_endproc
 211               	.LFE16:
 213               	.global	MFRC522_read
 215               	MFRC522_read:
 216               	.LFB18:
 633:main.c        ****     uint8_t val;
 217               		.loc 1 633 0
 218               		.cfi_startproc
 219               	.LVL11:
 220               	/* prologue: function */
 221               	/* frame size = 0 */
 222               	/* stack size = 0 */
 223               	.L__stack_usage = 0
 635:main.c        ****     SPI_send(((addr<<1)&0x7E) | 0x80);
 224               		.loc 1 635 0
 225 007c 2A98      		cbi 0x5,2
 636:main.c        ****     val = SPI_receive();
 226               		.loc 1 636 0
 227 007e 880F      		lsl r24
 228               	.LVL12:
 229 0080 8E77      		andi r24,lo8(126)
 230 0082 8068      		ori r24,lo8(-128)
 231 0084 0E94 0000 		call SPI_send
 232               	.LVL13:
 637:main.c        ****     PORTB |= (1<<PB2);
 233               		.loc 1 637 0
 234 0088 0E94 0000 		call SPI_receive
 235               	.LVL14:
 638:main.c        ****     return val;
 236               		.loc 1 638 0
 237 008c 2A9A      		sbi 0x5,2
 238               	/* epilogue start */
 640:main.c        **** 
 239               		.loc 1 640 0
 240 008e 0895      		ret
 241               		.cfi_endproc
 242               	.LFE18:
 244               	.global	MFRC522_setBitMask
 246               	MFRC522_setBitMask:
 247               	.LFB19:
 642:main.c        ****     uint8_t tmp = MFRC522_read(reg);
 248               		.loc 1 642 0
 249               		.cfi_startproc
 250               	.LVL15:
 251 0090 CF93      		push r28
 252               	.LCFI1:
 253               		.cfi_def_cfa_offset 3
 254               		.cfi_offset 28, -2
 255 0092 DF93      		push r29
 256               	.LCFI2:
 257               		.cfi_def_cfa_offset 4
 258               		.cfi_offset 29, -3
 259               	/* prologue: function */
 260               	/* frame size = 0 */
 261               	/* stack size = 2 */
 262               	.L__stack_usage = 2
 263 0094 D82F      		mov r29,r24
 264 0096 C62F      		mov r28,r22
 643:main.c        ****     MFRC522_write(reg, tmp | mask);
 265               		.loc 1 643 0
 266 0098 0E94 0000 		call MFRC522_read
 267               	.LVL16:
 644:main.c        **** }
 268               		.loc 1 644 0
 269 009c 682F      		mov r22,r24
 270 009e 6C2B      		or r22,r28
 271 00a0 8D2F      		mov r24,r29
 272               	.LVL17:
 273               	/* epilogue start */
 645:main.c        **** 
 274               		.loc 1 645 0
 275 00a2 DF91      		pop r29
 276               	.LVL18:
 277 00a4 CF91      		pop r28
 278               	.LVL19:
 644:main.c        **** }
 279               		.loc 1 644 0
 280 00a6 0C94 0000 		jmp MFRC522_write
 281               	.LVL20:
 282               		.cfi_endproc
 283               	.LFE19:
 285               	.global	MFRC522_clearBitMask
 287               	MFRC522_clearBitMask:
 288               	.LFB20:
 647:main.c        ****     uint8_t tmp = MFRC522_read(reg);
 289               		.loc 1 647 0
 290               		.cfi_startproc
 291               	.LVL21:
 292 00aa CF93      		push r28
 293               	.LCFI3:
 294               		.cfi_def_cfa_offset 3
 295               		.cfi_offset 28, -2
 296 00ac DF93      		push r29
 297               	.LCFI4:
 298               		.cfi_def_cfa_offset 4
 299               		.cfi_offset 29, -3
 300               	/* prologue: function */
 301               	/* frame size = 0 */
 302               	/* stack size = 2 */
 303               	.L__stack_usage = 2
 304 00ae D82F      		mov r29,r24
 305 00b0 C62F      		mov r28,r22
 648:main.c        ****     MFRC522_write(reg, tmp & (~mask));
 306               		.loc 1 648 0
 307 00b2 0E94 0000 		call MFRC522_read
 308               	.LVL22:
 649:main.c        **** }
 309               		.loc 1 649 0
 310 00b6 C095      		com r28
 311               	.LVL23:
 312 00b8 6C2F      		mov r22,r28
 313 00ba 6823      		and r22,r24
 314 00bc 8D2F      		mov r24,r29
 315               	.LVL24:
 316               	/* epilogue start */
 650:main.c        **** 
 317               		.loc 1 650 0
 318 00be DF91      		pop r29
 319               	.LVL25:
 320 00c0 CF91      		pop r28
 321               	.LVL26:
 649:main.c        **** }
 322               		.loc 1 649 0
 323 00c2 0C94 0000 		jmp MFRC522_write
 324               	.LVL27:
 325               		.cfi_endproc
 326               	.LFE20:
 328               	.global	MFRC522_antennaOn
 330               	MFRC522_antennaOn:
 331               	.LFB21:
 652:main.c        ****     uint8_t temp = MFRC522_read(TxControlReg);
 332               		.loc 1 652 0
 333               		.cfi_startproc
 334               	/* prologue: function */
 335               	/* frame size = 0 */
 336               	/* stack size = 0 */
 337               	.L__stack_usage = 0
 653:main.c        ****     if (!(temp & 0x03)) {
 338               		.loc 1 653 0
 339 00c6 84E1      		ldi r24,lo8(20)
 340 00c8 0E94 0000 		call MFRC522_read
 341               	.LVL28:
 654:main.c        ****         MFRC522_setBitMask(TxControlReg, 0x03);
 342               		.loc 1 654 0
 343 00cc 8370      		andi r24,lo8(3)
 344               	.LVL29:
 345 00ce 01F4      		brne .L15
 346               	.LBB405:
 347               	.LBB406:
 655:main.c        ****     }
 348               		.loc 1 655 0
 349 00d0 63E0      		ldi r22,lo8(3)
 350 00d2 84E1      		ldi r24,lo8(20)
 351 00d4 0C94 0000 		jmp MFRC522_setBitMask
 352               	.LVL30:
 353               	.L15:
 354               	/* epilogue start */
 355               	.LBE406:
 356               	.LBE405:
 657:main.c        **** 
 357               		.loc 1 657 0
 358 00d8 0895      		ret
 359               		.cfi_endproc
 360               	.LFE21:
 362               	.global	MFRC522_init
 364               	MFRC522_init:
 365               	.LFB15:
 611:main.c        ****     MFRC522_reset();
 366               		.loc 1 611 0
 367               		.cfi_startproc
 368               	/* prologue: function */
 369               	/* frame size = 0 */
 370               	/* stack size = 0 */
 371               	.L__stack_usage = 0
 612:main.c        ****     MFRC522_write(TModeReg, 0x8D);
 372               		.loc 1 612 0
 373 00da 0E94 0000 		call MFRC522_reset
 374               	.LVL31:
 613:main.c        ****     MFRC522_write(TPrescalerReg, 0x3E);
 375               		.loc 1 613 0
 376 00de 6DE8      		ldi r22,lo8(-115)
 377 00e0 8AE2      		ldi r24,lo8(42)
 378 00e2 0E94 0000 		call MFRC522_write
 379               	.LVL32:
 614:main.c        ****     MFRC522_write(TReloadRegL, 30);
 380               		.loc 1 614 0
 381 00e6 6EE3      		ldi r22,lo8(62)
 382 00e8 8BE2      		ldi r24,lo8(43)
 383 00ea 0E94 0000 		call MFRC522_write
 384               	.LVL33:
 615:main.c        ****     MFRC522_write(TReloadRegH, 0);
 385               		.loc 1 615 0
 386 00ee 6EE1      		ldi r22,lo8(30)
 387 00f0 8DE2      		ldi r24,lo8(45)
 388 00f2 0E94 0000 		call MFRC522_write
 389               	.LVL34:
 616:main.c        ****     MFRC522_write(TxASKReg, 0x40);
 390               		.loc 1 616 0
 391 00f6 60E0      		ldi r22,0
 392 00f8 8CE2      		ldi r24,lo8(44)
 393 00fa 0E94 0000 		call MFRC522_write
 394               	.LVL35:
 617:main.c        ****     MFRC522_write(ModeReg, 0x3D);
 395               		.loc 1 617 0
 396 00fe 60E4      		ldi r22,lo8(64)
 397 0100 85E1      		ldi r24,lo8(21)
 398 0102 0E94 0000 		call MFRC522_write
 399               	.LVL36:
 618:main.c        ****     MFRC522_antennaOn();
 400               		.loc 1 618 0
 401 0106 6DE3      		ldi r22,lo8(61)
 402 0108 81E1      		ldi r24,lo8(17)
 403 010a 0E94 0000 		call MFRC522_write
 404               	.LVL37:
 619:main.c        **** }
 405               		.loc 1 619 0
 406 010e 0C94 0000 		jmp MFRC522_antennaOn
 407               	.LVL38:
 408               		.cfi_endproc
 409               	.LFE15:
 411               	.global	MFRC522_toCard
 413               	MFRC522_toCard:
 414               	.LFB23:
 674:main.c        ****     uint8_t status = MI_ERR;
 415               		.loc 1 674 0
 416               		.cfi_startproc
 417               	.LVL39:
 418 0112 8F92      		push r8
 419               	.LCFI5:
 420               		.cfi_def_cfa_offset 3
 421               		.cfi_offset 8, -2
 422 0114 9F92      		push r9
 423               	.LCFI6:
 424               		.cfi_def_cfa_offset 4
 425               		.cfi_offset 9, -3
 426 0116 AF92      		push r10
 427               	.LCFI7:
 428               		.cfi_def_cfa_offset 5
 429               		.cfi_offset 10, -4
 430 0118 BF92      		push r11
 431               	.LCFI8:
 432               		.cfi_def_cfa_offset 6
 433               		.cfi_offset 11, -5
 434 011a CF92      		push r12
 435               	.LCFI9:
 436               		.cfi_def_cfa_offset 7
 437               		.cfi_offset 12, -6
 438 011c DF92      		push r13
 439               	.LCFI10:
 440               		.cfi_def_cfa_offset 8
 441               		.cfi_offset 13, -7
 442 011e EF92      		push r14
 443               	.LCFI11:
 444               		.cfi_def_cfa_offset 9
 445               		.cfi_offset 14, -8
 446 0120 FF92      		push r15
 447               	.LCFI12:
 448               		.cfi_def_cfa_offset 10
 449               		.cfi_offset 15, -9
 450 0122 0F93      		push r16
 451               	.LCFI13:
 452               		.cfi_def_cfa_offset 11
 453               		.cfi_offset 16, -10
 454 0124 1F93      		push r17
 455               	.LCFI14:
 456               		.cfi_def_cfa_offset 12
 457               		.cfi_offset 17, -11
 458 0126 CF93      		push r28
 459               	.LCFI15:
 460               		.cfi_def_cfa_offset 13
 461               		.cfi_offset 28, -12
 462 0128 DF93      		push r29
 463               	.LCFI16:
 464               		.cfi_def_cfa_offset 14
 465               		.cfi_offset 29, -13
 466               	/* prologue: function */
 467               	/* frame size = 0 */
 468               	/* stack size = 12 */
 469               	.L__stack_usage = 12
 470 012a D82F      		mov r29,r24
 471 012c 862E      		mov r8,r22
 472 012e B72E      		mov r11,r23
 473 0130 A42E      		mov r10,r20
 474 0132 6901      		movw r12,r18
 475               	.LVL40:
 689:main.c        ****             break;
 476               		.loc 1 689 0
 477 0134 90E3      		ldi r25,lo8(48)
 478 0136 992E      		mov r9,r25
 688:main.c        ****             waitIRq = 0x30;
 479               		.loc 1 688 0
 480 0138 C7E7      		ldi r28,lo8(119)
 682:main.c        ****         case PCD_AUTHENT:
 481               		.loc 1 682 0
 482 013a 8C30      		cpi r24,lo8(12)
 483 013c 01F0      		breq .L19
 685:main.c        ****             break;
 484               		.loc 1 685 0
 485 013e 20E1      		ldi r18,lo8(16)
 486 0140 922E      		mov r9,r18
 487               	.LVL41:
 684:main.c        ****             waitIRq = 0x10;
 488               		.loc 1 684 0
 489 0142 C2E1      		ldi r28,lo8(18)
 682:main.c        ****         case PCD_AUTHENT:
 490               		.loc 1 682 0
 491 0144 8E30      		cpi r24,lo8(14)
 492 0146 01F0      		breq .L19
 677:main.c        ****     uint8_t lastBits;
 493               		.loc 1 677 0
 494 0148 912C      		mov r9,__zero_reg__
 676:main.c        ****     uint8_t waitIRq = 0x00;
 495               		.loc 1 676 0
 496 014a C0E0      		ldi r28,0
 497               	.L19:
 498               	.LVL42:
 695:main.c        ****     MFRC522_clearBitMask(CommIrqReg, 0x80);
 499               		.loc 1 695 0
 500 014c 6C2F      		mov r22,r28
 501               	.LVL43:
 502 014e 6068      		ori r22,lo8(-128)
 503 0150 82E0      		ldi r24,lo8(2)
 504               	.LVL44:
 505 0152 0E94 0000 		call MFRC522_write
 506               	.LVL45:
 696:main.c        ****     MFRC522_setBitMask(FIFOLevelReg, 0x80);
 507               		.loc 1 696 0
 508 0156 60E8      		ldi r22,lo8(-128)
 509 0158 84E0      		ldi r24,lo8(4)
 510 015a 0E94 0000 		call MFRC522_clearBitMask
 511               	.LVL46:
 697:main.c        **** 
 512               		.loc 1 697 0
 513 015e 60E8      		ldi r22,lo8(-128)
 514 0160 8AE0      		ldi r24,lo8(10)
 515 0162 0E94 0000 		call MFRC522_setBitMask
 516               	.LVL47:
 699:main.c        **** 
 517               		.loc 1 699 0
 518 0166 60E0      		ldi r22,0
 519 0168 81E0      		ldi r24,lo8(1)
 520 016a 0E94 0000 		call MFRC522_write
 521               	.LVL48:
 522 016e E82C      		mov r14,r8
 523 0170 FB2C      		mov r15,r11
 524 0172 AE0C      		add r10,r14
 525 0174 BF2C      		mov r11,r15
 526 0176 B11C      		adc r11,__zero_reg__
 527               	.LVL49:
 528               	.L22:
 701:main.c        ****         MFRC522_write(FIFODataReg, sendData[i]);
 529               		.loc 1 701 0 discriminator 1
 530 0178 AE14      		cp r10,r14
 531 017a BF04      		cpc r11,r15
 532 017c 01F0      		breq .+2
 533 017e 00C0      		rjmp .L23
 705:main.c        ****     if (command == PCD_TRANSCEIVE) {
 534               		.loc 1 705 0
 535 0180 6D2F      		mov r22,r29
 536 0182 81E0      		ldi r24,lo8(1)
 537 0184 0E94 0000 		call MFRC522_write
 538               	.LVL50:
 706:main.c        ****         MFRC522_setBitMask(BitFramingReg, 0x80);
 539               		.loc 1 706 0
 540 0188 DC30      		cpi r29,lo8(12)
 541 018a 01F4      		brne .L24
 707:main.c        ****     }
 542               		.loc 1 707 0
 543 018c 60E8      		ldi r22,lo8(-128)
 544 018e 8DE0      		ldi r24,lo8(13)
 545 0190 0E94 0000 		call MFRC522_setBitMask
 546               	.LVL51:
 547               	.L24:
 676:main.c        ****     uint8_t waitIRq = 0x00;
 548               		.loc 1 676 0 discriminator 3
 549 0194 80ED      		ldi r24,lo8(-48)
 550 0196 F82E      		mov r15,r24
 714:main.c        **** 
 551               		.loc 1 714 0 discriminator 3
 552 0198 6894      		set
 553 019a 90F8      		bld r9,0
 554               	.LVL52:
 555               	.L26:
 712:main.c        ****         i--;
 556               		.loc 1 712 0 discriminator 3
 557 019c 84E0      		ldi r24,lo8(4)
 558 019e 0E94 0000 		call MFRC522_read
 559               	.LVL53:
 560 01a2 E82E      		mov r14,r24
 561               	.LVL54:
 713:main.c        ****     } while ((i != 0) && !(n & 0x01) && !(n & waitIRq));
 562               		.loc 1 713 0 discriminator 3
 563 01a4 FA94      		dec r15
 564               	.LVL55:
 714:main.c        **** 
 565               		.loc 1 714 0 discriminator 3
 566 01a6 FF20      		tst r15
 567 01a8 01F0      		breq .L25
 714:main.c        **** 
 568               		.loc 1 714 0 is_stmt 0 discriminator 1
 569 01aa 892D      		mov r24,r9
 570 01ac 8E21      		and r24,r14
 571 01ae 01F0      		breq .L26
 572               	.L25:
 716:main.c        **** 
 573               		.loc 1 716 0 is_stmt 1
 574 01b0 60E8      		ldi r22,lo8(-128)
 575 01b2 8DE0      		ldi r24,lo8(13)
 576 01b4 0E94 0000 		call MFRC522_clearBitMask
 577               	.LVL56:
 718:main.c        ****         if (!(MFRC522_read(ErrorReg) & 0x1B)) {
 578               		.loc 1 718 0
 579 01b8 FF20      		tst r15
 580 01ba 01F4      		brne .+2
 581 01bc 00C0      		rjmp .L27
 719:main.c        ****             status = MI_OK;
 582               		.loc 1 719 0
 583 01be 86E0      		ldi r24,lo8(6)
 584 01c0 0E94 0000 		call MFRC522_read
 585               	.LVL57:
 586 01c4 8B71      		andi r24,lo8(27)
 587 01c6 01F0      		breq .+2
 588 01c8 00C0      		rjmp .L27
 589               	.LVL58:
 590 01ca C170      		andi r28,lo8(1)
 591               	.LVL59:
 592 01cc CE21      		and r28,r14
 593               	.LVL60:
 725:main.c        ****                 n = MFRC522_read(FIFOLevelReg);
 594               		.loc 1 725 0
 595 01ce DC30      		cpi r29,lo8(12)
 596 01d0 01F4      		brne .L18
 726:main.c        ****                 lastBits = MFRC522_read(ControlReg) & 0x07;
 597               		.loc 1 726 0
 598 01d2 8AE0      		ldi r24,lo8(10)
 599 01d4 0E94 0000 		call MFRC522_read
 600               	.LVL61:
 601 01d8 D82F      		mov r29,r24
 602               	.LVL62:
 727:main.c        ****                 if (lastBits) {
 603               		.loc 1 727 0
 604 01da 8CE0      		ldi r24,lo8(12)
 605               	.LVL63:
 606 01dc 0E94 0000 		call MFRC522_read
 607               	.LVL64:
 608 01e0 982F      		mov r25,r24
 609 01e2 9770      		andi r25,lo8(7)
 610               	.LVL65:
 728:main.c        ****                     *backLen = (n - 1) * 8 + lastBits;
 611               		.loc 1 728 0
 612 01e4 01F0      		breq .L29
 729:main.c        ****                 } else {
 613               		.loc 1 729 0
 614 01e6 8FE1      		ldi r24,lo8(31)
 615 01e8 8D0F      		add r24,r29
 616 01ea 880F      		lsl r24
 617 01ec 880F      		lsl r24
 618 01ee 880F      		lsl r24
 619 01f0 890F      		add r24,r25
 620               	.L45:
 731:main.c        ****                 }
 621               		.loc 1 731 0
 622 01f2 F801      		movw r30,r16
 623 01f4 8083      		st Z,r24
 734:main.c        ****                     n = 1;
 624               		.loc 1 734 0
 625 01f6 DD23      		tst r29
 626 01f8 01F0      		breq .L31
 627 01fa D131      		cpi r29,lo8(17)
 628 01fc 00F0      		brlo .L32
 629 01fe D0E1      		ldi r29,lo8(16)
 630               	.LVL66:
 631               	.L32:
 632 0200 1C2D      		mov r17,r12
 633 0202 7601      		movw r14,r12
 634               	.LVL67:
 635               	.L33:
 742:main.c        ****                 }
 636               		.loc 1 742 0 discriminator 3
 637 0204 89E0      		ldi r24,lo8(9)
 638 0206 0E94 0000 		call MFRC522_read
 639               	.LVL68:
 640 020a F701      		movw r30,r14
 641 020c 8193      		st Z+,r24
 642 020e 7F01      		movw r14,r30
 643               	.LVL69:
 741:main.c        ****                     backData[i] = MFRC522_read(FIFODataReg);
 644               		.loc 1 741 0 discriminator 3
 645 0210 8E2F      		mov r24,r30
 646 0212 811B      		sub r24,r17
 647 0214 8D17      		cp r24,r29
 648 0216 00F0      		brlo .L33
 649               	.LVL70:
 650               	.L18:
 751:main.c        **** 
 651               		.loc 1 751 0
 652 0218 8C2F      		mov r24,r28
 653               	/* epilogue start */
 654 021a DF91      		pop r29
 655 021c CF91      		pop r28
 656 021e 1F91      		pop r17
 657 0220 0F91      		pop r16
 658               	.LVL71:
 659 0222 FF90      		pop r15
 660 0224 EF90      		pop r14
 661 0226 DF90      		pop r13
 662 0228 CF90      		pop r12
 663               	.LVL72:
 664 022a BF90      		pop r11
 665 022c AF90      		pop r10
 666 022e 9F90      		pop r9
 667 0230 8F90      		pop r8
 668 0232 0895      		ret
 669               	.LVL73:
 670               	.L23:
 702:main.c        ****     }
 671               		.loc 1 702 0 discriminator 3
 672 0234 F701      		movw r30,r14
 673 0236 6191      		ld r22,Z+
 674 0238 7F01      		movw r14,r30
 675               	.LVL74:
 676 023a 89E0      		ldi r24,lo8(9)
 677 023c 0E94 0000 		call MFRC522_write
 678               	.LVL75:
 679 0240 00C0      		rjmp .L22
 680               	.LVL76:
 681               	.L29:
 731:main.c        ****                 }
 682               		.loc 1 731 0
 683 0242 8D2F      		mov r24,r29
 684 0244 880F      		lsl r24
 685 0246 880F      		lsl r24
 686 0248 880F      		lsl r24
 687 024a 00C0      		rjmp .L45
 688               	.LVL77:
 689               	.L27:
 675:main.c        ****     uint8_t irqEn = 0x00;
 690               		.loc 1 675 0
 691 024c C2E0      		ldi r28,lo8(2)
 692               	.LVL78:
 750:main.c        **** }
 693               		.loc 1 750 0
 694 024e 00C0      		rjmp .L18
 695               	.LVL79:
 696               	.L31:
 742:main.c        ****                 }
 697               		.loc 1 742 0
 698 0250 89E0      		ldi r24,lo8(9)
 699 0252 0E94 0000 		call MFRC522_read
 700               	.LVL80:
 701 0256 F601      		movw r30,r12
 702 0258 8083      		st Z,r24
 703               	.LVL81:
 704 025a 00C0      		rjmp .L18
 705               		.cfi_endproc
 706               	.LFE23:
 708               	.global	MFRC522_request
 710               	MFRC522_request:
 711               	.LFB22:
 659:main.c        ****     uint8_t status;
 712               		.loc 1 659 0
 713               		.cfi_startproc
 714               	.LVL82:
 715 025c EF92      		push r14
 716               	.LCFI17:
 717               		.cfi_def_cfa_offset 3
 718               		.cfi_offset 14, -2
 719 025e FF92      		push r15
 720               	.LCFI18:
 721               		.cfi_def_cfa_offset 4
 722               		.cfi_offset 15, -3
 723 0260 0F93      		push r16
 724               	.LCFI19:
 725               		.cfi_def_cfa_offset 5
 726               		.cfi_offset 16, -4
 727 0262 1F93      		push r17
 728               	.LCFI20:
 729               		.cfi_def_cfa_offset 6
 730               		.cfi_offset 17, -5
 731 0264 CF93      		push r28
 732               	.LCFI21:
 733               		.cfi_def_cfa_offset 7
 734               		.cfi_offset 28, -6
 735 0266 DF93      		push r29
 736               	.LCFI22:
 737               		.cfi_def_cfa_offset 8
 738               		.cfi_offset 29, -7
 739 0268 1F92      		push __zero_reg__
 740               	.LCFI23:
 741               		.cfi_def_cfa_offset 9
 742 026a CDB7      		in r28,__SP_L__
 743 026c DEB7      		in r29,__SP_H__
 744               	.LCFI24:
 745               		.cfi_def_cfa_register 28
 746               	/* prologue: function */
 747               	/* frame size = 1 */
 748               	/* stack size = 7 */
 749               	.L__stack_usage = 7
 750 026e 182F      		mov r17,r24
 751 0270 7B01      		movw r14,r22
 663:main.c        ****     TagType[0] = reqMode;
 752               		.loc 1 663 0
 753 0272 67E0      		ldi r22,lo8(7)
 754               	.LVL83:
 755 0274 8DE0      		ldi r24,lo8(13)
 756               	.LVL84:
 757 0276 0E94 0000 		call MFRC522_write
 758               	.LVL85:
 664:main.c        ****     status = MFRC522_toCard(PCD_TRANSCEIVE, TagType, 1, TagType, &backBits);
 759               		.loc 1 664 0
 760 027a F701      		movw r30,r14
 761 027c 1083      		st Z,r17
 665:main.c        **** 
 762               		.loc 1 665 0
 763 027e 8E01      		movw r16,r28
 764 0280 0F5F      		subi r16,-1
 765 0282 1F4F      		sbci r17,-1
 766 0284 9701      		movw r18,r14
 767 0286 41E0      		ldi r20,lo8(1)
 768 0288 B701      		movw r22,r14
 769 028a 8CE0      		ldi r24,lo8(12)
 770 028c 0E94 0000 		call MFRC522_toCard
 771               	.LVL86:
 667:main.c        ****         status = MI_ERR;
 772               		.loc 1 667 0
 773 0290 8111      		cpse r24,__zero_reg__
 774 0292 00C0      		rjmp .L49
 667:main.c        ****         status = MI_ERR;
 775               		.loc 1 667 0 is_stmt 0 discriminator 1
 776 0294 9981      		ldd r25,Y+1
 777 0296 9031      		cpi r25,lo8(16)
 778 0298 01F0      		breq .L46
 779               	.L49:
 668:main.c        ****     }
 780               		.loc 1 668 0 is_stmt 1
 781 029a 82E0      		ldi r24,lo8(2)
 782               	.LVL87:
 783               	.L46:
 784               	/* epilogue start */
 672:main.c        **** 
 785               		.loc 1 672 0
 786 029c 0F90      		pop __tmp_reg__
 787 029e DF91      		pop r29
 788 02a0 CF91      		pop r28
 789 02a2 1F91      		pop r17
 790               	.LVL88:
 791 02a4 0F91      		pop r16
 792 02a6 FF90      		pop r15
 793 02a8 EF90      		pop r14
 794               	.LVL89:
 795 02aa 0895      		ret
 796               		.cfi_endproc
 797               	.LFE22:
 799               	.global	MFRC522_anticoll
 801               	MFRC522_anticoll:
 802               	.LFB24:
 753:main.c        ****     uint8_t status;
 803               		.loc 1 753 0
 804               		.cfi_startproc
 805               	.LVL90:
 806 02ac EF92      		push r14
 807               	.LCFI25:
 808               		.cfi_def_cfa_offset 3
 809               		.cfi_offset 14, -2
 810 02ae FF92      		push r15
 811               	.LCFI26:
 812               		.cfi_def_cfa_offset 4
 813               		.cfi_offset 15, -3
 814 02b0 0F93      		push r16
 815               	.LCFI27:
 816               		.cfi_def_cfa_offset 5
 817               		.cfi_offset 16, -4
 818 02b2 1F93      		push r17
 819               	.LCFI28:
 820               		.cfi_def_cfa_offset 6
 821               		.cfi_offset 17, -5
 822 02b4 CF93      		push r28
 823               	.LCFI29:
 824               		.cfi_def_cfa_offset 7
 825               		.cfi_offset 28, -6
 826 02b6 DF93      		push r29
 827               	.LCFI30:
 828               		.cfi_def_cfa_offset 8
 829               		.cfi_offset 29, -7
 830 02b8 1F92      		push __zero_reg__
 831               	.LCFI31:
 832               		.cfi_def_cfa_offset 9
 833 02ba CDB7      		in r28,__SP_L__
 834 02bc DEB7      		in r29,__SP_H__
 835               	.LCFI32:
 836               		.cfi_def_cfa_register 28
 837               	/* prologue: function */
 838               	/* frame size = 1 */
 839               	/* stack size = 7 */
 840               	.L__stack_usage = 7
 841 02be 7C01      		movw r14,r24
 842               	.LVL91:
 759:main.c        ****     serNum[0] = PICC_ANTICOLL;
 843               		.loc 1 759 0
 844 02c0 60E0      		ldi r22,0
 845 02c2 8DE0      		ldi r24,lo8(13)
 846               	.LVL92:
 847 02c4 0E94 0000 		call MFRC522_write
 848               	.LVL93:
 760:main.c        ****     serNum[1] = 0x20;
 849               		.loc 1 760 0
 850 02c8 83E9      		ldi r24,lo8(-109)
 851 02ca F701      		movw r30,r14
 852 02cc 8083      		st Z,r24
 761:main.c        ****     status = MFRC522_toCard(PCD_TRANSCEIVE, serNum, 2, serNum, &unLen);
 853               		.loc 1 761 0
 854 02ce 80E2      		ldi r24,lo8(32)
 855 02d0 8183      		std Z+1,r24
 762:main.c        **** 
 856               		.loc 1 762 0
 857 02d2 8E01      		movw r16,r28
 858 02d4 0F5F      		subi r16,-1
 859 02d6 1F4F      		sbci r17,-1
 860 02d8 9701      		movw r18,r14
 861 02da 42E0      		ldi r20,lo8(2)
 862 02dc B701      		movw r22,r14
 863 02de 8CE0      		ldi r24,lo8(12)
 864 02e0 0E94 0000 		call MFRC522_toCard
 865               	.LVL94:
 764:main.c        ****         for (i = 0; i < 4; i++) {
 866               		.loc 1 764 0
 867 02e4 8111      		cpse r24,__zero_reg__
 868 02e6 00C0      		rjmp .L50
 869 02e8 F701      		movw r30,r14
 870 02ea 9701      		movw r18,r14
 871 02ec 2C5F      		subi r18,-4
 872 02ee 3F4F      		sbci r19,-1
 873               	.LBB409:
 874               	.LBB410:
 756:main.c        ****     uint8_t unLen;
 875               		.loc 1 756 0
 876 02f0 90E0      		ldi r25,0
 877               	.L52:
 878               	.LVL95:
 766:main.c        ****         }
 879               		.loc 1 766 0
 880 02f2 4191      		ld r20,Z+
 881               	.LVL96:
 882 02f4 9427      		eor r25,r20
 883               	.LVL97:
 765:main.c        ****             serNumCheck ^= serNum[i];
 884               		.loc 1 765 0
 885 02f6 E217      		cp r30,r18
 886 02f8 F307      		cpc r31,r19
 887 02fa 01F4      		brne .L52
 768:main.c        ****             status = MI_ERR;
 888               		.loc 1 768 0
 889 02fc F701      		movw r30,r14
 890               	.LVL98:
 891 02fe 2481      		ldd r18,Z+4
 892 0300 9213      		cpse r25,r18
 769:main.c        ****         }
 893               		.loc 1 769 0
 894 0302 82E0      		ldi r24,lo8(2)
 895               	.LVL99:
 896               	.L50:
 897               	/* epilogue start */
 898               	.LBE410:
 899               	.LBE409:
 774:main.c        **** 
 900               		.loc 1 774 0
 901 0304 0F90      		pop __tmp_reg__
 902 0306 DF91      		pop r29
 903 0308 CF91      		pop r28
 904 030a 1F91      		pop r17
 905 030c 0F91      		pop r16
 906 030e FF90      		pop r15
 907 0310 EF90      		pop r14
 908               	.LVL100:
 909 0312 0895      		ret
 910               		.cfi_endproc
 911               	.LFE24:
 913               	.global	initLEDs_Buzzer
 915               	initLEDs_Buzzer:
 916               	.LFB25:
 776:main.c        ****     	// Initialize both LEDs and the buzzer
 917               		.loc 1 776 0
 918               		.cfi_startproc
 919               	/* prologue: function */
 920               	/* frame size = 0 */
 921               	/* stack size = 0 */
 922               	.L__stack_usage = 0
 778:main.c        **** }
 923               		.loc 1 778 0
 924 0314 8AB1      		in r24,0xa
 925 0316 886E      		ori r24,lo8(-24)
 926 0318 8AB9      		out 0xa,r24
 927               	/* epilogue start */
 779:main.c        **** 
 928               		.loc 1 779 0
 929 031a 0895      		ret
 930               		.cfi_endproc
 931               	.LFE25:
 933               	.global	blinkLED_Buzzer
 935               	blinkLED_Buzzer:
 936               	.LFB26:
 781:main.c        ****     // Blink the specified LED
 937               		.loc 1 781 0
 938               		.cfi_startproc
 939               	.LVL101:
 940               	/* prologue: function */
 941               	/* frame size = 0 */
 942               	/* stack size = 0 */
 943               	.L__stack_usage = 0
 783:main.c        ****         	PORTD |= (1<<led_pin);
 944               		.loc 1 783 0
 945 031c 8330      		cpi r24,lo8(3)
 946 031e 01F4      		brne .L56
 784:main.c        **** 		PORTD |= (1<<Buzzer_PIN);
 947               		.loc 1 784 0
 948 0320 5B9A      		sbi 0xb,3
 785:main.c        ****         	_delay_ms(50);         
 949               		.loc 1 785 0
 950 0322 5F9A      		sbi 0xb,7
 951               	.LVL102:
 952               	.LBB411:
 953               	.LBB412:
 954               		.loc 2 187 0
 955 0324 2FEF      		ldi r18,lo8(159999)
 956 0326 80E7      		ldi r24,hi8(159999)
 957 0328 92E0      		ldi r25,hlo8(159999)
 958 032a 2150      	1:	subi r18,1
 959 032c 8040      		sbci r24,0
 960 032e 9040      		sbci r25,0
 961 0330 01F4      		brne 1b
 962               	.LVL103:
 963 0332 00C0      		rjmp .
 964 0334 0000      		nop
 965               	.LVL104:
 966               	.LBE412:
 967               	.LBE411:
 787:main.c        **** 		PORTD &= ~(1<<Buzzer_PIN);
 968               		.loc 1 787 0
 969 0336 5B98      		cbi 0xb,3
 970               	.L59:
 795:main.c        **** 
 971               		.loc 1 795 0
 972 0338 5F98      		cbi 0xb,7
 973 033a 0895      		ret
 974               	.LVL105:
 975               	.L56:
 790:main.c        ****         	PORTD |= (1<<led_pin);
 976               		.loc 1 790 0
 977 033c 8530      		cpi r24,lo8(5)
 978 033e 01F4      		brne .L58
 791:main.c        **** 		PORTD |= (1<<Buzzer_PIN);
 979               		.loc 1 791 0
 980 0340 5D9A      		sbi 0xb,5
 792:main.c        ****         	_delay_ms(50);         
 981               		.loc 1 792 0
 982 0342 5F9A      		sbi 0xb,7
 983               	.LVL106:
 984               	.LBB413:
 985               	.LBB414:
 986               		.loc 2 187 0
 987 0344 2FEF      		ldi r18,lo8(159999)
 988 0346 80E7      		ldi r24,hi8(159999)
 989 0348 92E0      		ldi r25,hlo8(159999)
 990 034a 2150      	1:	subi r18,1
 991 034c 8040      		sbci r24,0
 992 034e 9040      		sbci r25,0
 993 0350 01F4      		brne 1b
 994               	.LVL107:
 995 0352 00C0      		rjmp .
 996 0354 0000      		nop
 997               	.LVL108:
 998               	.LBE414:
 999               	.LBE413:
 794:main.c        **** 		PORTD &= ~(1<<Buzzer_PIN);
 1000               		.loc 1 794 0
 1001 0356 5D98      		cbi 0xb,5
 1002 0358 00C0      		rjmp .L59
 1003               	.LVL109:
 1004               	.L58:
 797:main.c        **** 		PORTD |= (1<<led_pin);
 1005               		.loc 1 797 0
 1006 035a 8630      		cpi r24,lo8(6)
 1007 035c 01F4      		brne .L55
 1008 035e 0C94 0000 		jmp blinkLED_Buzzer.part.2
 1009               	.LVL110:
 1010               	.L55:
 1011               	/* epilogue start */
 1012               		.loc 1 804 0
 1013 0362 0895      		ret
 1014               		.cfi_endproc
 1015               	.LFE26:
 1017               	.global	i2c_init
 1019               	i2c_init:
 1020               	.LFB27:
 805:main.c        **** 
 806:main.c        **** void i2c_init(void) {
 1021               		.loc 1 806 0
 1022               		.cfi_startproc
 1023               	/* prologue: function */
 1024               	/* frame size = 0 */
 1025               	/* stack size = 0 */
 1026               	.L__stack_usage = 0
 807:main.c        ****     // Initialize I2C (TWI) interface
 808:main.c        ****     TWSR = 0x00; // Prescaler value of 1
 1027               		.loc 1 808 0
 1028 0364 1092 B900 		sts 185,__zero_reg__
 809:main.c        ****     TWBR = ((F_CPU/100000UL) - 16) / 2; // SCL frequency 100kHz
 1029               		.loc 1 809 0
 1030 0368 88E4      		ldi r24,lo8(72)
 1031 036a 8093 B800 		sts 184,r24
 1032               	/* epilogue start */
 810:main.c        **** }
 1033               		.loc 1 810 0
 1034 036e 0895      		ret
 1035               		.cfi_endproc
 1036               	.LFE27:
 1038               	.global	i2c_start
 1040               	i2c_start:
 1041               	.LFB28:
 811:main.c        **** 
 812:main.c        **** void i2c_start(uint8_t address) {
 1042               		.loc 1 812 0
 1043               		.cfi_startproc
 1044               	.LVL111:
 1045               	/* prologue: function */
 1046               	/* frame size = 0 */
 1047               	/* stack size = 0 */
 1048               	.L__stack_usage = 0
 813:main.c        ****     // Send start condition
 814:main.c        ****     TWCR = (1<<TWSTA) | (1<<TWEN) | (1<<TWINT);
 1049               		.loc 1 814 0
 1050 0370 94EA      		ldi r25,lo8(-92)
 1051 0372 9093 BC00 		sts 188,r25
 1052               	.L62:
 815:main.c        ****     while (!(TWCR & (1<<TWINT))); // Wait for start to be transmitted
 1053               		.loc 1 815 0 discriminator 1
 1054 0376 9091 BC00 		lds r25,188
 1055 037a 97FF      		sbrs r25,7
 1056 037c 00C0      		rjmp .L62
 816:main.c        **** 
 817:main.c        ****     // Load slave address into data register
 818:main.c        ****     TWDR = address;
 1057               		.loc 1 818 0
 1058 037e 8093 BB00 		sts 187,r24
 819:main.c        ****     TWCR = (1<<TWEN) | (1<<TWINT); // Clear TWINT to start transmission
 1059               		.loc 1 819 0
 1060 0382 84E8      		ldi r24,lo8(-124)
 1061               	.LVL112:
 1062 0384 8093 BC00 		sts 188,r24
 1063               	.LVL113:
 1064               	.L63:
 820:main.c        ****     while (!(TWCR & (1<<TWINT))); // Wait for end of transmission
 1065               		.loc 1 820 0 discriminator 1
 1066 0388 8091 BC00 		lds r24,188
 1067 038c 87FF      		sbrs r24,7
 1068 038e 00C0      		rjmp .L63
 1069               	/* epilogue start */
 821:main.c        **** }
 1070               		.loc 1 821 0
 1071 0390 0895      		ret
 1072               		.cfi_endproc
 1073               	.LFE28:
 1075               	.global	i2c_stop
 1077               	i2c_stop:
 1078               	.LFB29:
 822:main.c        **** 
 823:main.c        **** void i2c_stop(void) {
 1079               		.loc 1 823 0
 1080               		.cfi_startproc
 1081               	/* prologue: function */
 1082               	/* frame size = 0 */
 1083               	/* stack size = 0 */
 1084               	.L__stack_usage = 0
 824:main.c        ****     // Send stop condition
 825:main.c        ****     TWCR = (1<<TWSTO) | (1<<TWEN) | (1<<TWINT);
 1085               		.loc 1 825 0
 1086 0392 84E9      		ldi r24,lo8(-108)
 1087 0394 8093 BC00 		sts 188,r24
 1088               	.L67:
 826:main.c        ****     while (TWCR & (1<<TWSTO)); // Wait for stop to be transmitted
 1089               		.loc 1 826 0 discriminator 1
 1090 0398 8091 BC00 		lds r24,188
 1091 039c 84FD      		sbrc r24,4
 1092 039e 00C0      		rjmp .L67
 1093               	/* epilogue start */
 827:main.c        **** }
 1094               		.loc 1 827 0
 1095 03a0 0895      		ret
 1096               		.cfi_endproc
 1097               	.LFE29:
 1099               	.global	i2c_write
 1101               	i2c_write:
 1102               	.LFB30:
 828:main.c        **** 
 829:main.c        **** void i2c_write(uint8_t data) {
 1103               		.loc 1 829 0
 1104               		.cfi_startproc
 1105               	.LVL114:
 1106               	/* prologue: function */
 1107               	/* frame size = 0 */
 1108               	/* stack size = 0 */
 1109               	.L__stack_usage = 0
 830:main.c        ****     TWDR = data;
 1110               		.loc 1 830 0
 1111 03a2 8093 BB00 		sts 187,r24
 831:main.c        ****     TWCR = (1<<TWEN) | (1<<TWINT);
 1112               		.loc 1 831 0
 1113 03a6 84E8      		ldi r24,lo8(-124)
 1114               	.LVL115:
 1115 03a8 8093 BC00 		sts 188,r24
 1116               	.LVL116:
 1117               	.L70:
 832:main.c        ****     while (!(TWCR & (1<<TWINT))); // Wait for end of transmission
 1118               		.loc 1 832 0 discriminator 1
 1119 03ac 8091 BC00 		lds r24,188
 1120 03b0 87FF      		sbrs r24,7
 1121 03b2 00C0      		rjmp .L70
 1122               	/* epilogue start */
 833:main.c        **** }
 1123               		.loc 1 833 0
 1124 03b4 0895      		ret
 1125               		.cfi_endproc
 1126               	.LFE30:
 1128               	.global	LCD_SendCommand
 1130               	LCD_SendCommand:
 1131               	.LFB32:
 834:main.c        **** 
 835:main.c        **** void LCD_Init(void) {
 836:main.c        ****     // Initialize LCD (Assuming 4-bit mode)
 837:main.c        ****     _delay_ms(50); // Wait for more than 40ms after VCC rises to 4.5V
 838:main.c        ****     LCD_SendCommand(0x03);
 839:main.c        ****     _delay_ms(5);  // Wait for more than 4.1ms
 840:main.c        ****     LCD_SendCommand(0x03);
 841:main.c        ****     _delay_us(150);
 842:main.c        ****     LCD_SendCommand(0x03);
 843:main.c        ****     LCD_SendCommand(0x02); // Set to 4-bit mode
 844:main.c        ****     LCD_SendCommand(0x28); // Function set: 4-bit, 2 lines, 5x8 dots
 845:main.c        ****     LCD_SendCommand(0x0C); // Display ON, cursor OFF, blink OFF
 846:main.c        ****     LCD_SendCommand(0x06); // Entry mode set: increment automatically, no shift
 847:main.c        ****     LCD_SendCommand(0x01); // Clear display
 848:main.c        ****     _delay_ms(2);  // Delay after clearing display
 849:main.c        **** }
 850:main.c        **** 
 851:main.c        **** void LCD_SendCommand(uint8_t cmd) {
 1132               		.loc 1 851 0
 1133               		.cfi_startproc
 1134               	.LVL117:
 1135 03b6 1F93      		push r17
 1136               	.LCFI33:
 1137               		.cfi_def_cfa_offset 3
 1138               		.cfi_offset 17, -2
 1139 03b8 CF93      		push r28
 1140               	.LCFI34:
 1141               		.cfi_def_cfa_offset 4
 1142               		.cfi_offset 28, -3
 1143 03ba DF93      		push r29
 1144               	.LCFI35:
 1145               		.cfi_def_cfa_offset 5
 1146               		.cfi_offset 29, -4
 1147               	/* prologue: function */
 1148               	/* frame size = 0 */
 1149               	/* stack size = 3 */
 1150               	.L__stack_usage = 3
 1151 03bc C82F      		mov r28,r24
 852:main.c        ****     // Send a command to the LCD
 853:main.c        ****     i2c_start(LCD_ADDR<<1);
 1152               		.loc 1 853 0
 1153 03be 8EE4      		ldi r24,lo8(78)
 1154               	.LVL118:
 1155 03c0 0E94 0000 		call i2c_start
 1156               	.LVL119:
 854:main.c        ****     i2c_write((cmd & 0xF0) | 0x08); // Send high nibble
 1157               		.loc 1 854 0
 1158 03c4 1C2F      		mov r17,r28
 1159 03c6 107F      		andi r17,lo8(-16)
 1160 03c8 D12F      		mov r29,r17
 1161 03ca D860      		ori r29,lo8(8)
 1162 03cc 8D2F      		mov r24,r29
 1163 03ce 0E94 0000 		call i2c_write
 1164               	.LVL120:
 855:main.c        ****     i2c_write((cmd & 0xF0) | 0x0C); // Enable bit high
 1165               		.loc 1 855 0
 1166 03d2 812F      		mov r24,r17
 1167 03d4 8C60      		ori r24,lo8(12)
 1168 03d6 0E94 0000 		call i2c_write
 1169               	.LVL121:
 856:main.c        ****     i2c_write((cmd & 0xF0) | 0x08); // Enable bit low
 1170               		.loc 1 856 0
 1171 03da 8D2F      		mov r24,r29
 1172 03dc 0E94 0000 		call i2c_write
 1173               	.LVL122:
 857:main.c        ****     i2c_write((cmd << 4) | 0x08);   // Send low nibble
 1174               		.loc 1 857 0
 1175 03e0 80E1      		ldi r24,lo8(16)
 1176 03e2 C89F      		mul r28,r24
 1177 03e4 E001      		movw r28,r0
 1178 03e6 1124      		clr __zero_reg__
 1179               	.LVL123:
 1180 03e8 DC2F      		mov r29,r28
 1181 03ea D860      		ori r29,lo8(8)
 1182 03ec 8D2F      		mov r24,r29
 1183 03ee 0E94 0000 		call i2c_write
 1184               	.LVL124:
 858:main.c        ****     i2c_write((cmd << 4) | 0x0C);   // Enable bit high
 1185               		.loc 1 858 0
 1186 03f2 8C2F      		mov r24,r28
 1187 03f4 8C60      		ori r24,lo8(12)
 1188 03f6 0E94 0000 		call i2c_write
 1189               	.LVL125:
 859:main.c        ****     i2c_write((cmd << 4) | 0x08);   // Enable bit low
 1190               		.loc 1 859 0
 1191 03fa 8D2F      		mov r24,r29
 1192 03fc 0E94 0000 		call i2c_write
 1193               	.LVL126:
 1194               	/* epilogue start */
 860:main.c        ****     i2c_stop();
 861:main.c        **** }
 1195               		.loc 1 861 0
 1196 0400 DF91      		pop r29
 1197 0402 CF91      		pop r28
 1198 0404 1F91      		pop r17
 860:main.c        ****     i2c_stop();
 1199               		.loc 1 860 0
 1200 0406 0C94 0000 		jmp i2c_stop
 1201               	.LVL127:
 1202               		.cfi_endproc
 1203               	.LFE32:
 1205               	.global	LCD_Init
 1207               	LCD_Init:
 1208               	.LFB31:
 835:main.c        ****     // Initialize LCD (Assuming 4-bit mode)
 1209               		.loc 1 835 0
 1210               		.cfi_startproc
 1211               	/* prologue: function */
 1212               	/* frame size = 0 */
 1213               	/* stack size = 0 */
 1214               	.L__stack_usage = 0
 1215               	.LVL128:
 1216               	.LBB415:
 1217               	.LBB416:
 1218               		.loc 2 187 0
 1219 040a 2FEF      		ldi r18,lo8(159999)
 1220 040c 80E7      		ldi r24,hi8(159999)
 1221 040e 92E0      		ldi r25,hlo8(159999)
 1222 0410 2150      	1:	subi r18,1
 1223 0412 8040      		sbci r24,0
 1224 0414 9040      		sbci r25,0
 1225 0416 01F4      		brne 1b
 1226 0418 00C0      		rjmp .
 1227 041a 0000      		nop
 1228               	.LVL129:
 1229               	.LBE416:
 1230               	.LBE415:
 838:main.c        ****     _delay_ms(5);  // Wait for more than 4.1ms
 1231               		.loc 1 838 0
 1232 041c 83E0      		ldi r24,lo8(3)
 1233 041e 0E94 0000 		call LCD_SendCommand
 1234               	.LVL130:
 1235               	.LBB417:
 1236               	.LBB418:
 1237               		.loc 2 187 0
 1238 0422 8FE1      		ldi r24,lo8(19999)
 1239 0424 9EE4      		ldi r25,hi8(19999)
 1240 0426 0197      	1:	sbiw r24,1
 1241 0428 01F4      		brne 1b
 1242 042a 00C0      		rjmp .
 1243 042c 0000      		nop
 1244               	.LVL131:
 1245               	.LBE418:
 1246               	.LBE417:
 840:main.c        ****     _delay_us(150);
 1247               		.loc 1 840 0
 1248 042e 83E0      		ldi r24,lo8(3)
 1249 0430 0E94 0000 		call LCD_SendCommand
 1250               	.LVL132:
 1251               	.LBB419:
 1252               	.LBB420:
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1253               		.loc 2 276 0
 1254 0434 87E5      		ldi r24,lo8(599)
 1255 0436 92E0      		ldi r25,hi8(599)
 1256 0438 0197      	1:	sbiw r24,1
 1257 043a 01F4      		brne 1b
 1258 043c 00C0      		rjmp .
 1259 043e 0000      		nop
 1260               	.LVL133:
 1261               	.LBE420:
 1262               	.LBE419:
 842:main.c        ****     LCD_SendCommand(0x02); // Set to 4-bit mode
 1263               		.loc 1 842 0
 1264 0440 83E0      		ldi r24,lo8(3)
 1265 0442 0E94 0000 		call LCD_SendCommand
 1266               	.LVL134:
 843:main.c        ****     LCD_SendCommand(0x28); // Function set: 4-bit, 2 lines, 5x8 dots
 1267               		.loc 1 843 0
 1268 0446 82E0      		ldi r24,lo8(2)
 1269 0448 0E94 0000 		call LCD_SendCommand
 1270               	.LVL135:
 844:main.c        ****     LCD_SendCommand(0x0C); // Display ON, cursor OFF, blink OFF
 1271               		.loc 1 844 0
 1272 044c 88E2      		ldi r24,lo8(40)
 1273 044e 0E94 0000 		call LCD_SendCommand
 1274               	.LVL136:
 845:main.c        ****     LCD_SendCommand(0x06); // Entry mode set: increment automatically, no shift
 1275               		.loc 1 845 0
 1276 0452 8CE0      		ldi r24,lo8(12)
 1277 0454 0E94 0000 		call LCD_SendCommand
 1278               	.LVL137:
 846:main.c        ****     LCD_SendCommand(0x01); // Clear display
 1279               		.loc 1 846 0
 1280 0458 86E0      		ldi r24,lo8(6)
 1281 045a 0E94 0000 		call LCD_SendCommand
 1282               	.LVL138:
 847:main.c        ****     _delay_ms(2);  // Delay after clearing display
 1283               		.loc 1 847 0
 1284 045e 81E0      		ldi r24,lo8(1)
 1285 0460 0E94 0000 		call LCD_SendCommand
 1286               	.LVL139:
 1287               	.LBB421:
 1288               	.LBB422:
 187:/usr/lib/avr/include/util/delay.h **** 
 1289               		.loc 2 187 0
 1290 0464 8FE3      		ldi r24,lo8(7999)
 1291 0466 9FE1      		ldi r25,hi8(7999)
 1292 0468 0197      	1:	sbiw r24,1
 1293 046a 01F4      		brne 1b
 1294 046c 00C0      		rjmp .
 1295 046e 0000      		nop
 1296               	.LVL140:
 1297               	/* epilogue start */
 1298               	.LBE422:
 1299               	.LBE421:
 849:main.c        **** 
 1300               		.loc 1 849 0
 1301 0470 0895      		ret
 1302               		.cfi_endproc
 1303               	.LFE31:
 1305               	.global	LCD_SendData
 1307               	LCD_SendData:
 1308               	.LFB33:
 862:main.c        **** 
 863:main.c        **** void LCD_SendData(uint8_t data) {
 1309               		.loc 1 863 0
 1310               		.cfi_startproc
 1311               	.LVL141:
 1312 0472 1F93      		push r17
 1313               	.LCFI36:
 1314               		.cfi_def_cfa_offset 3
 1315               		.cfi_offset 17, -2
 1316 0474 CF93      		push r28
 1317               	.LCFI37:
 1318               		.cfi_def_cfa_offset 4
 1319               		.cfi_offset 28, -3
 1320 0476 DF93      		push r29
 1321               	.LCFI38:
 1322               		.cfi_def_cfa_offset 5
 1323               		.cfi_offset 29, -4
 1324               	/* prologue: function */
 1325               	/* frame size = 0 */
 1326               	/* stack size = 3 */
 1327               	.L__stack_usage = 3
 1328 0478 C82F      		mov r28,r24
 864:main.c        ****     // Send data to the LCD
 865:main.c        ****     i2c_start(LCD_ADDR<<1);
 1329               		.loc 1 865 0
 1330 047a 8EE4      		ldi r24,lo8(78)
 1331               	.LVL142:
 1332 047c 0E94 0000 		call i2c_start
 1333               	.LVL143:
 866:main.c        ****     i2c_write((data & 0xF0) | 0x09); // Send high nibble
 1334               		.loc 1 866 0
 1335 0480 1C2F      		mov r17,r28
 1336 0482 107F      		andi r17,lo8(-16)
 1337 0484 D12F      		mov r29,r17
 1338 0486 D960      		ori r29,lo8(9)
 1339 0488 8D2F      		mov r24,r29
 1340 048a 0E94 0000 		call i2c_write
 1341               	.LVL144:
 867:main.c        ****     i2c_write((data & 0xF0) | 0x0D); // Enable bit high
 1342               		.loc 1 867 0
 1343 048e 812F      		mov r24,r17
 1344 0490 8D60      		ori r24,lo8(13)
 1345 0492 0E94 0000 		call i2c_write
 1346               	.LVL145:
 868:main.c        ****     i2c_write((data & 0xF0) | 0x09); // Enable bit low
 1347               		.loc 1 868 0
 1348 0496 8D2F      		mov r24,r29
 1349 0498 0E94 0000 		call i2c_write
 1350               	.LVL146:
 869:main.c        ****     i2c_write((data << 4) | 0x09);   // Send low nibble
 1351               		.loc 1 869 0
 1352 049c 80E1      		ldi r24,lo8(16)
 1353 049e C89F      		mul r28,r24
 1354 04a0 E001      		movw r28,r0
 1355 04a2 1124      		clr __zero_reg__
 1356               	.LVL147:
 1357 04a4 DC2F      		mov r29,r28
 1358 04a6 D960      		ori r29,lo8(9)
 1359 04a8 8D2F      		mov r24,r29
 1360 04aa 0E94 0000 		call i2c_write
 1361               	.LVL148:
 870:main.c        ****     i2c_write((data << 4) | 0x0D);   // Enable bit high
 1362               		.loc 1 870 0
 1363 04ae 8C2F      		mov r24,r28
 1364 04b0 8D60      		ori r24,lo8(13)
 1365 04b2 0E94 0000 		call i2c_write
 1366               	.LVL149:
 871:main.c        ****     i2c_write((data << 4) | 0x09);   // Enable bit low
 1367               		.loc 1 871 0
 1368 04b6 8D2F      		mov r24,r29
 1369 04b8 0E94 0000 		call i2c_write
 1370               	.LVL150:
 1371               	/* epilogue start */
 872:main.c        ****     i2c_stop();
 873:main.c        **** }
 1372               		.loc 1 873 0
 1373 04bc DF91      		pop r29
 1374 04be CF91      		pop r28
 1375 04c0 1F91      		pop r17
 872:main.c        ****     i2c_stop();
 1376               		.loc 1 872 0
 1377 04c2 0C94 0000 		jmp i2c_stop
 1378               	.LVL151:
 1379               		.cfi_endproc
 1380               	.LFE33:
 1382               	.global	LCD_Print
 1384               	LCD_Print:
 1385               	.LFB34:
 874:main.c        **** 
 875:main.c        **** void LCD_Print(char *str) {
 1386               		.loc 1 875 0
 1387               		.cfi_startproc
 1388               	.LVL152:
 1389 04c6 CF93      		push r28
 1390               	.LCFI39:
 1391               		.cfi_def_cfa_offset 3
 1392               		.cfi_offset 28, -2
 1393 04c8 DF93      		push r29
 1394               	.LCFI40:
 1395               		.cfi_def_cfa_offset 4
 1396               		.cfi_offset 29, -3
 1397               	/* prologue: function */
 1398               	/* frame size = 0 */
 1399               	/* stack size = 2 */
 1400               	.L__stack_usage = 2
 1401 04ca EC01      		movw r28,r24
 1402               	.LVL153:
 1403               	.L76:
 876:main.c        ****     while (*str) {
 1404               		.loc 1 876 0
 1405 04cc 8991      		ld r24,Y+
 1406               	.LVL154:
 1407 04ce 8111      		cpse r24,__zero_reg__
 1408 04d0 00C0      		rjmp .L77
 1409               	/* epilogue start */
 877:main.c        ****         LCD_SendData(*str++);
 878:main.c        ****     }
 879:main.c        **** }
 1410               		.loc 1 879 0
 1411 04d2 DF91      		pop r29
 1412 04d4 CF91      		pop r28
 1413               	.LVL155:
 1414 04d6 0895      		ret
 1415               	.LVL156:
 1416               	.L77:
 877:main.c        ****         LCD_SendData(*str++);
 1417               		.loc 1 877 0
 1418 04d8 0E94 0000 		call LCD_SendData
 1419               	.LVL157:
 1420 04dc 00C0      		rjmp .L76
 1421               		.cfi_endproc
 1422               	.LFE34:
 1424               	.global	LCD_SetPosition
 1426               	LCD_SetPosition:
 1427               	.LFB35:
 880:main.c        **** 
 881:main.c        **** void LCD_SetPosition(uint8_t row, uint8_t col) {
 1428               		.loc 1 881 0
 1429               		.cfi_startproc
 1430               	.LVL158:
 1431               	/* prologue: function */
 1432               	/* frame size = 0 */
 1433               	/* stack size = 0 */
 1434               	.L__stack_usage = 0
 882:main.c        ****     uint8_t pos = (row == 0) ? (0x80 + col) : (0xC0 + col);
 1435               		.loc 1 882 0
 1436 04de 8111      		cpse r24,__zero_reg__
 1437 04e0 00C0      		rjmp .L79
 1438               		.loc 1 882 0 is_stmt 0 discriminator 1
 1439 04e2 80E8      		ldi r24,lo8(-128)
 1440               	.LVL159:
 1441               	.L81:
 1442               		.loc 1 882 0 discriminator 2
 1443 04e4 860F      		add r24,r22
 1444               	.LVL160:
 883:main.c        ****     LCD_SendCommand(pos);
 1445               		.loc 1 883 0 is_stmt 1 discriminator 2
 1446 04e6 0C94 0000 		jmp LCD_SendCommand
 1447               	.LVL161:
 1448               	.L79:
 882:main.c        ****     uint8_t pos = (row == 0) ? (0x80 + col) : (0xC0 + col);
 1449               		.loc 1 882 0 discriminator 2
 1450 04ea 80EC      		ldi r24,lo8(-64)
 1451               	.LVL162:
 1452 04ec 00C0      		rjmp .L81
 1453               		.cfi_endproc
 1454               	.LFE35:
 1456               	.global	LCD_Clear
 1458               	LCD_Clear:
 1459               	.LFB36:
 884:main.c        **** }
 885:main.c        **** 
 886:main.c        **** void LCD_Clear(void) {
 1460               		.loc 1 886 0
 1461               		.cfi_startproc
 1462               	/* prologue: function */
 1463               	/* frame size = 0 */
 1464               	/* stack size = 0 */
 1465               	.L__stack_usage = 0
 887:main.c        ****     LCD_SendCommand(0x01);  // Send clear display command
 1466               		.loc 1 887 0
 1467 04ee 81E0      		ldi r24,lo8(1)
 1468 04f0 0E94 0000 		call LCD_SendCommand
 1469               	.LVL163:
 1470               	.LBB423:
 1471               	.LBB424:
 187:/usr/lib/avr/include/util/delay.h **** 
 1472               		.loc 2 187 0
 1473 04f4 8FE3      		ldi r24,lo8(7999)
 1474 04f6 9FE1      		ldi r25,hi8(7999)
 1475 04f8 0197      	1:	sbiw r24,1
 1476 04fa 01F4      		brne 1b
 1477 04fc 00C0      		rjmp .
 1478 04fe 0000      		nop
 1479               	.LVL164:
 1480               	/* epilogue start */
 1481               	.LBE424:
 1482               	.LBE423:
 888:main.c        ****     _delay_ms(2);           // Wait for the command to execute (it takes a bit of time)
 889:main.c        **** }
 1483               		.loc 1 889 0
 1484 0500 0895      		ret
 1485               		.cfi_endproc
 1486               	.LFE36:
 1488               		.section	.rodata.str1.1,"aMS",@progbits,1
 1489               	.LC0:
 1490 0000 2020 2020 		.string	"                "
 1490      2020 2020 
 1490      2020 2020 
 1490      2020 2020 
 1490      00
 1491               		.text
 1492               	.global	LCD_ScrollText
 1494               	LCD_ScrollText:
 1495               	.LFB37:
 890:main.c        **** 
 891:main.c        **** // Scroll text on the specified row
 892:main.c        **** void LCD_ScrollText(const char *str, uint8_t row, uint8_t scrollDist, uint8_t *index) {
 1496               		.loc 1 892 0
 1497               		.cfi_startproc
 1498               	.LVL165:
 1499 0502 8F92      		push r8
 1500               	.LCFI41:
 1501               		.cfi_def_cfa_offset 3
 1502               		.cfi_offset 8, -2
 1503 0504 9F92      		push r9
 1504               	.LCFI42:
 1505               		.cfi_def_cfa_offset 4
 1506               		.cfi_offset 9, -3
 1507 0506 AF92      		push r10
 1508               	.LCFI43:
 1509               		.cfi_def_cfa_offset 5
 1510               		.cfi_offset 10, -4
 1511 0508 BF92      		push r11
 1512               	.LCFI44:
 1513               		.cfi_def_cfa_offset 6
 1514               		.cfi_offset 11, -5
 1515 050a CF92      		push r12
 1516               	.LCFI45:
 1517               		.cfi_def_cfa_offset 7
 1518               		.cfi_offset 12, -6
 1519 050c DF92      		push r13
 1520               	.LCFI46:
 1521               		.cfi_def_cfa_offset 8
 1522               		.cfi_offset 13, -7
 1523 050e EF92      		push r14
 1524               	.LCFI47:
 1525               		.cfi_def_cfa_offset 9
 1526               		.cfi_offset 14, -8
 1527 0510 FF92      		push r15
 1528               	.LCFI48:
 1529               		.cfi_def_cfa_offset 10
 1530               		.cfi_offset 15, -9
 1531 0512 0F93      		push r16
 1532               	.LCFI49:
 1533               		.cfi_def_cfa_offset 11
 1534               		.cfi_offset 16, -10
 1535 0514 1F93      		push r17
 1536               	.LCFI50:
 1537               		.cfi_def_cfa_offset 12
 1538               		.cfi_offset 17, -11
 1539 0516 CF93      		push r28
 1540               	.LCFI51:
 1541               		.cfi_def_cfa_offset 13
 1542               		.cfi_offset 28, -12
 1543 0518 DF93      		push r29
 1544               	.LCFI52:
 1545               		.cfi_def_cfa_offset 14
 1546               		.cfi_offset 29, -13
 1547 051a CDB7      		in r28,__SP_L__
 1548 051c DEB7      		in r29,__SP_H__
 1549               	.LCFI53:
 1550               		.cfi_def_cfa_register 28
 1551 051e 6197      		sbiw r28,17
 1552               	.LCFI54:
 1553               		.cfi_def_cfa_offset 31
 1554 0520 0FB6      		in __tmp_reg__,__SREG__
 1555 0522 F894      		cli
 1556 0524 DEBF      		out __SP_H__,r29
 1557 0526 0FBE      		out __SREG__,__tmp_reg__
 1558 0528 CDBF      		out __SP_L__,r28
 1559               	/* prologue: function */
 1560               	/* frame size = 17 */
 1561               	/* stack size = 29 */
 1562               	.L__stack_usage = 29
 1563 052a 6C01      		movw r12,r24
 1564 052c 862E      		mov r8,r22
 1565 052e 942E      		mov r9,r20
 1566 0530 7901      		movw r14,r18
 893:main.c        ****     uint8_t len = strlen(str);
 1567               		.loc 1 893 0
 1568 0532 FC01      		movw r30,r24
 1569               		0:
 1570 0534 0190      		ld __tmp_reg__,Z+
 1571 0536 0020      		tst __tmp_reg__
 1572 0538 01F4      		brne 0b
 1573 053a 3197      		sbiw r30,1
 1574 053c E81B      		sub r30,r24
 1575 053e F90B      		sbc r31,r25
 1576               	.LVL166:
 894:main.c        ****     char buffer[MAX_LEN + 1];
 895:main.c        **** 
 896:main.c        ****     char *scrollText = malloc(len + MAX_LEN + 1);
 1577               		.loc 1 896 0
 1578 0540 8F01      		movw r16,r30
 1579 0542 1127      		clr r17
 1580 0544 C801      		movw r24,r16
 1581               	.LVL167:
 1582 0546 4196      		adiw r24,17
 1583 0548 0E94 0000 		call malloc
 1584               	.LVL168:
 1585 054c 5C01      		movw r10,r24
 1586               	.LVL169:
 897:main.c        ****     if (scrollText == NULL) return;
 1587               		.loc 1 897 0
 1588 054e 0097      		sbiw r24,0
 1589 0550 01F0      		breq .L83
 898:main.c        **** 
 899:main.c        ****     strcpy(scrollText, str);
 1590               		.loc 1 899 0
 1591 0552 B601      		movw r22,r12
 1592 0554 0E94 0000 		call strcpy
 1593               	.LVL170:
 900:main.c        ****     strcat(scrollText, "                "); // Adding extra spaces for smooth scroll
 1594               		.loc 1 900 0
 1595 0558 60E0      		ldi r22,lo8(.LC0)
 1596 055a 70E0      		ldi r23,hi8(.LC0)
 1597 055c C501      		movw r24,r10
 1598 055e 0E94 0000 		call strcat
 1599               	.LVL171:
 901:main.c        **** 
 902:main.c        ****     // Copy the portion of the string to display
 903:main.c        ****     strncpy(buffer, scrollText + *index, MAX_LEN);
 1600               		.loc 1 903 0
 1601 0562 F701      		movw r30,r14
 1602 0564 6081      		ld r22,Z
 1603 0566 6A0D      		add r22,r10
 1604 0568 7B2D      		mov r23,r11
 1605 056a 711D      		adc r23,__zero_reg__
 1606 056c 40E1      		ldi r20,lo8(16)
 1607 056e 50E0      		ldi r21,0
 1608 0570 CE01      		movw r24,r28
 1609 0572 0196      		adiw r24,1
 1610 0574 0E94 0000 		call strncpy
 1611               	.LVL172:
 904:main.c        ****     buffer[MAX_LEN] = '\0';  // Null-terminate
 1612               		.loc 1 904 0
 1613 0578 198A      		std Y+17,__zero_reg__
 905:main.c        **** 
 906:main.c        ****     LCD_SetPosition(row, 0);  // Set the row position
 1614               		.loc 1 906 0
 1615 057a 60E0      		ldi r22,0
 1616 057c 882D      		mov r24,r8
 1617 057e 0E94 0000 		call LCD_SetPosition
 1618               	.LVL173:
 907:main.c        ****     LCD_Print(buffer);  // Print the current scroll position
 1619               		.loc 1 907 0
 1620 0582 CE01      		movw r24,r28
 1621 0584 0196      		adiw r24,1
 1622 0586 0E94 0000 		call LCD_Print
 1623               	.LVL174:
 908:main.c        **** 
 909:main.c        ****     // Increment the scroll index
 910:main.c        ****     (*index)++;
 1624               		.loc 1 910 0
 1625 058a F701      		movw r30,r14
 1626 058c 8081      		ld r24,Z
 1627 058e 8F5F      		subi r24,lo8(-(1))
 911:main.c        ****     if (*index >= len + scrollDist) {
 1628               		.loc 1 911 0
 1629 0590 090D      		add r16,r9
 1630 0592 111D      		adc r17,__zero_reg__
 1631 0594 8017      		cp r24,r16
 1632 0596 1106      		cpc __zero_reg__,r17
 1633 0598 04F4      		brge .L85
 910:main.c        ****     if (*index >= len + scrollDist) {
 1634               		.loc 1 910 0
 1635 059a 8083      		st Z,r24
 1636               	.L86:
 912:main.c        ****         *index = 0;  // Reset the index once the entire text has scrolled
 913:main.c        ****     }
 914:main.c        **** 
 915:main.c        ****     free(scrollText);  // Free the allocated memory
 1637               		.loc 1 915 0
 1638 059c C501      		movw r24,r10
 1639               	/* epilogue start */
 916:main.c        **** }
 1640               		.loc 1 916 0
 1641 059e 6196      		adiw r28,17
 1642 05a0 0FB6      		in __tmp_reg__,__SREG__
 1643 05a2 F894      		cli
 1644 05a4 DEBF      		out __SP_H__,r29
 1645 05a6 0FBE      		out __SREG__,__tmp_reg__
 1646 05a8 CDBF      		out __SP_L__,r28
 1647 05aa DF91      		pop r29
 1648 05ac CF91      		pop r28
 1649 05ae 1F91      		pop r17
 1650 05b0 0F91      		pop r16
 1651 05b2 FF90      		pop r15
 1652 05b4 EF90      		pop r14
 1653               	.LVL175:
 1654 05b6 DF90      		pop r13
 1655 05b8 CF90      		pop r12
 1656               	.LVL176:
 1657 05ba BF90      		pop r11
 1658 05bc AF90      		pop r10
 1659               	.LVL177:
 1660 05be 9F90      		pop r9
 1661               	.LVL178:
 1662 05c0 8F90      		pop r8
 1663               	.LVL179:
 915:main.c        **** }
 1664               		.loc 1 915 0
 1665 05c2 0C94 0000 		jmp free
 1666               	.LVL180:
 1667               	.L85:
 912:main.c        ****         *index = 0;  // Reset the index once the entire text has scrolled
 1668               		.loc 1 912 0
 1669 05c6 1082      		st Z,__zero_reg__
 1670 05c8 00C0      		rjmp .L86
 1671               	.L83:
 1672               	/* epilogue start */
 1673               		.loc 1 916 0
 1674 05ca 6196      		adiw r28,17
 1675 05cc 0FB6      		in __tmp_reg__,__SREG__
 1676 05ce F894      		cli
 1677 05d0 DEBF      		out __SP_H__,r29
 1678 05d2 0FBE      		out __SREG__,__tmp_reg__
 1679 05d4 CDBF      		out __SP_L__,r28
 1680 05d6 DF91      		pop r29
 1681 05d8 CF91      		pop r28
 1682 05da 1F91      		pop r17
 1683 05dc 0F91      		pop r16
 1684 05de FF90      		pop r15
 1685 05e0 EF90      		pop r14
 1686               	.LVL181:
 1687 05e2 DF90      		pop r13
 1688 05e4 CF90      		pop r12
 1689               	.LVL182:
 1690 05e6 BF90      		pop r11
 1691 05e8 AF90      		pop r10
 1692               	.LVL183:
 1693 05ea 9F90      		pop r9
 1694               	.LVL184:
 1695 05ec 8F90      		pop r8
 1696               	.LVL185:
 1697 05ee 0895      		ret
 1698               		.cfi_endproc
 1699               	.LFE37:
 1701               	.global	storeCard
 1703               	storeCard:
 1704               	.LFB38:
 917:main.c        **** 
 918:main.c        **** void storeCard(uint8_t *serial) {
 1705               		.loc 1 918 0
 1706               		.cfi_startproc
 1707               	.LVL186:
 1708 05f0 0F93      		push r16
 1709               	.LCFI55:
 1710               		.cfi_def_cfa_offset 3
 1711               		.cfi_offset 16, -2
 1712 05f2 1F93      		push r17
 1713               	.LCFI56:
 1714               		.cfi_def_cfa_offset 4
 1715               		.cfi_offset 17, -3
 1716 05f4 CF93      		push r28
 1717               	.LCFI57:
 1718               		.cfi_def_cfa_offset 5
 1719               		.cfi_offset 28, -4
 1720               	/* prologue: function */
 1721               	/* frame size = 0 */
 1722               	/* stack size = 3 */
 1723               	.L__stack_usage = 3
 1724 05f6 8C01      		movw r16,r24
 919:main.c        ****     uint8_t userNum = eeprom_read_byte(&userCount);
 1725               		.loc 1 919 0
 1726 05f8 80E0      		ldi r24,lo8(userCount)
 1727 05fa 90E0      		ldi r25,hi8(userCount)
 1728               	.LVL187:
 1729 05fc 0E94 0000 		call eeprom_read_byte
 1730               	.LVL188:
 1731 0600 C82F      		mov r28,r24
 1732               	.LVL189:
 920:main.c        ****     eeprom_write_block(serial, storedIDs[userNum], 5);
 1733               		.loc 1 920 0
 1734 0602 85E0      		ldi r24,lo8(5)
 1735               	.LVL190:
 1736 0604 C89F      		mul r28,r24
 1737 0606 B001      		movw r22,r0
 1738 0608 1124      		clr __zero_reg__
 1739 060a 6050      		subi r22,lo8(-(storedIDs))
 1740 060c 7040      		sbci r23,hi8(-(storedIDs))
 1741 060e 45E0      		ldi r20,lo8(5)
 1742 0610 50E0      		ldi r21,0
 1743 0612 C801      		movw r24,r16
 1744 0614 0E94 0000 		call eeprom_write_block
 1745               	.LVL191:
 921:main.c        ****     eeprom_write_byte(&userCount, userNum + 1);
 1746               		.loc 1 921 0
 1747 0618 61E0      		ldi r22,lo8(1)
 1748 061a 6C0F      		add r22,r28
 1749 061c 80E0      		ldi r24,lo8(userCount)
 1750 061e 90E0      		ldi r25,hi8(userCount)
 1751 0620 0E94 0000 		call eeprom_write_byte
 1752               	.LVL192:
 920:main.c        ****     eeprom_write_block(serial, storedIDs[userNum], 5);
 1753               		.loc 1 920 0
 1754 0624 EC2F      		mov r30,r28
 1755 0626 F0E0      		ldi r31,0
 922:main.c        ****     votedUsers[userNum] = 0;  // Mark as not voted in RAM
 1756               		.loc 1 922 0
 1757 0628 E050      		subi r30,lo8(-(votedUsers))
 1758 062a F040      		sbci r31,hi8(-(votedUsers))
 1759 062c 1082      		st Z,__zero_reg__
 1760               	/* epilogue start */
 923:main.c        **** }
 1761               		.loc 1 923 0
 1762 062e CF91      		pop r28
 1763               	.LVL193:
 1764 0630 1F91      		pop r17
 1765 0632 0F91      		pop r16
 1766               	.LVL194:
 1767 0634 0895      		ret
 1768               		.cfi_endproc
 1769               	.LFE38:
 1771               	.global	getUserIndex
 1773               	getUserIndex:
 1774               	.LFB39:
 924:main.c        **** 
 925:main.c        **** uint8_t getUserIndex(uint8_t *serial) {
 1775               		.loc 1 925 0
 1776               		.cfi_startproc
 1777               	.LVL195:
 1778 0636 CF92      		push r12
 1779               	.LCFI58:
 1780               		.cfi_def_cfa_offset 3
 1781               		.cfi_offset 12, -2
 1782 0638 DF92      		push r13
 1783               	.LCFI59:
 1784               		.cfi_def_cfa_offset 4
 1785               		.cfi_offset 13, -3
 1786 063a EF92      		push r14
 1787               	.LCFI60:
 1788               		.cfi_def_cfa_offset 5
 1789               		.cfi_offset 14, -4
 1790 063c FF92      		push r15
 1791               	.LCFI61:
 1792               		.cfi_def_cfa_offset 6
 1793               		.cfi_offset 15, -5
 1794 063e 0F93      		push r16
 1795               	.LCFI62:
 1796               		.cfi_def_cfa_offset 7
 1797               		.cfi_offset 16, -6
 1798 0640 1F93      		push r17
 1799               	.LCFI63:
 1800               		.cfi_def_cfa_offset 8
 1801               		.cfi_offset 17, -7
 1802 0642 CF93      		push r28
 1803               	.LCFI64:
 1804               		.cfi_def_cfa_offset 9
 1805               		.cfi_offset 28, -8
 1806 0644 DF93      		push r29
 1807               	.LCFI65:
 1808               		.cfi_def_cfa_offset 10
 1809               		.cfi_offset 29, -9
 1810 0646 00D0      		rcall .
 1811 0648 00D0      		rcall .
 1812 064a 1F92      		push __zero_reg__
 1813               	.LCFI66:
 1814               		.cfi_def_cfa_offset 15
 1815 064c CDB7      		in r28,__SP_L__
 1816 064e DEB7      		in r29,__SP_H__
 1817               	.LCFI67:
 1818               		.cfi_def_cfa_register 28
 1819               	/* prologue: function */
 1820               	/* frame size = 5 */
 1821               	/* stack size = 13 */
 1822               	.L__stack_usage = 13
 1823 0650 6C01      		movw r12,r24
 926:main.c        ****     uint8_t userNum = eeprom_read_byte(&userCount);
 1824               		.loc 1 926 0
 1825 0652 80E0      		ldi r24,lo8(userCount)
 1826 0654 90E0      		ldi r25,hi8(userCount)
 1827               	.LVL196:
 1828 0656 0E94 0000 		call eeprom_read_byte
 1829               	.LVL197:
 1830 065a 082F      		mov r16,r24
 1831               	.LVL198:
 1832 065c 80E0      		ldi r24,lo8(storedIDs)
 1833 065e E82E      		mov r14,r24
 1834 0660 80E0      		ldi r24,hi8(storedIDs)
 1835 0662 F82E      		mov r15,r24
 1836               	.LBB425:
 927:main.c        ****     uint8_t storedSerial[5];
 928:main.c        ****     for (uint8_t i = 0; i < userNum; i++) {
 1837               		.loc 1 928 0
 1838 0664 10E0      		ldi r17,0
 1839               	.LVL199:
 1840               	.L89:
 1841               		.loc 1 928 0 is_stmt 0 discriminator 1
 1842 0666 1013      		cpse r17,r16
 1843 0668 00C0      		rjmp .L91
 1844               	.LBE425:
 929:main.c        ****         eeprom_read_block(storedSerial, storedIDs[i], 5);
 930:main.c        ****         if (memcmp(serial, storedSerial, 5) == 0) {
 931:main.c        ****             return i;  // Return the index if user is found
 932:main.c        ****         }
 933:main.c        ****     }
 934:main.c        ****     return 255;  // Return 255 if user is not found (invalid)
 1845               		.loc 1 934 0 is_stmt 1
 1846 066a 1FEF      		ldi r17,lo8(-1)
 1847               	.LVL200:
 1848               	.L88:
 935:main.c        **** }
 1849               		.loc 1 935 0
 1850 066c 812F      		mov r24,r17
 1851               	/* epilogue start */
 1852 066e 0F90      		pop __tmp_reg__
 1853 0670 0F90      		pop __tmp_reg__
 1854 0672 0F90      		pop __tmp_reg__
 1855 0674 0F90      		pop __tmp_reg__
 1856 0676 0F90      		pop __tmp_reg__
 1857 0678 DF91      		pop r29
 1858 067a CF91      		pop r28
 1859 067c 1F91      		pop r17
 1860 067e 0F91      		pop r16
 1861               	.LVL201:
 1862 0680 FF90      		pop r15
 1863 0682 EF90      		pop r14
 1864 0684 DF90      		pop r13
 1865 0686 CF90      		pop r12
 1866               	.LVL202:
 1867 0688 0895      		ret
 1868               	.LVL203:
 1869               	.L91:
 1870               	.LBB426:
 929:main.c        ****         eeprom_read_block(storedSerial, storedIDs[i], 5);
 1871               		.loc 1 929 0
 1872 068a 45E0      		ldi r20,lo8(5)
 1873 068c 50E0      		ldi r21,0
 1874 068e B701      		movw r22,r14
 1875 0690 CE01      		movw r24,r28
 1876 0692 0196      		adiw r24,1
 1877 0694 0E94 0000 		call eeprom_read_block
 1878               	.LVL204:
 930:main.c        ****             return i;  // Return the index if user is found
 1879               		.loc 1 930 0
 1880 0698 45E0      		ldi r20,lo8(5)
 1881 069a 50E0      		ldi r21,0
 1882 069c BE01      		movw r22,r28
 1883 069e 6F5F      		subi r22,-1
 1884 06a0 7F4F      		sbci r23,-1
 1885 06a2 C601      		movw r24,r12
 1886 06a4 0E94 0000 		call memcmp
 1887               	.LVL205:
 1888 06a8 25E0      		ldi r18,5
 1889 06aa E20E      		add r14,r18
 1890 06ac F11C      		adc r15,__zero_reg__
 1891 06ae 892B      		or r24,r25
 1892 06b0 01F0      		breq .L88
 928:main.c        ****         eeprom_read_block(storedSerial, storedIDs[i], 5);
 1893               		.loc 1 928 0 discriminator 2
 1894 06b2 1F5F      		subi r17,lo8(-(1))
 1895               	.LVL206:
 1896 06b4 00C0      		rjmp .L89
 1897               	.LBE426:
 1898               		.cfi_endproc
 1899               	.LFE39:
 1901               	.global	isRegistered
 1903               	isRegistered:
 1904               	.LFB40:
 936:main.c        **** 
 937:main.c        **** uint8_t isRegistered(uint8_t *serial) {
 1905               		.loc 1 937 0
 1906               		.cfi_startproc
 1907               	.LVL207:
 1908 06b6 AF92      		push r10
 1909               	.LCFI68:
 1910               		.cfi_def_cfa_offset 3
 1911               		.cfi_offset 10, -2
 1912 06b8 BF92      		push r11
 1913               	.LCFI69:
 1914               		.cfi_def_cfa_offset 4
 1915               		.cfi_offset 11, -3
 1916 06ba CF92      		push r12
 1917               	.LCFI70:
 1918               		.cfi_def_cfa_offset 5
 1919               		.cfi_offset 12, -4
 1920 06bc DF92      		push r13
 1921               	.LCFI71:
 1922               		.cfi_def_cfa_offset 6
 1923               		.cfi_offset 13, -5
 1924 06be EF92      		push r14
 1925               	.LCFI72:
 1926               		.cfi_def_cfa_offset 7
 1927               		.cfi_offset 14, -6
 1928 06c0 FF92      		push r15
 1929               	.LCFI73:
 1930               		.cfi_def_cfa_offset 8
 1931               		.cfi_offset 15, -7
 1932 06c2 0F93      		push r16
 1933               	.LCFI74:
 1934               		.cfi_def_cfa_offset 9
 1935               		.cfi_offset 16, -8
 1936 06c4 1F93      		push r17
 1937               	.LCFI75:
 1938               		.cfi_def_cfa_offset 10
 1939               		.cfi_offset 17, -9
 1940 06c6 CF93      		push r28
 1941               	.LCFI76:
 1942               		.cfi_def_cfa_offset 11
 1943               		.cfi_offset 28, -10
 1944 06c8 DF93      		push r29
 1945               	.LCFI77:
 1946               		.cfi_def_cfa_offset 12
 1947               		.cfi_offset 29, -11
 1948 06ca 00D0      		rcall .
 1949 06cc 00D0      		rcall .
 1950 06ce 1F92      		push __zero_reg__
 1951               	.LCFI78:
 1952               		.cfi_def_cfa_offset 17
 1953 06d0 CDB7      		in r28,__SP_L__
 1954 06d2 DEB7      		in r29,__SP_H__
 1955               	.LCFI79:
 1956               		.cfi_def_cfa_register 28
 1957               	/* prologue: function */
 1958               	/* frame size = 5 */
 1959               	/* stack size = 15 */
 1960               	.L__stack_usage = 15
 1961 06d4 5C01      		movw r10,r24
 938:main.c        ****     uint8_t userNum = eeprom_read_byte(&userCount);
 1962               		.loc 1 938 0
 1963 06d6 80E0      		ldi r24,lo8(userCount)
 1964 06d8 90E0      		ldi r25,hi8(userCount)
 1965               	.LVL208:
 1966 06da 0E94 0000 		call eeprom_read_byte
 1967               	.LVL209:
 1968 06de 90E0      		ldi r25,lo8(storedIDs)
 1969 06e0 C92E      		mov r12,r25
 1970 06e2 90E0      		ldi r25,hi8(storedIDs)
 1971 06e4 D92E      		mov r13,r25
 1972               	.LBB427:
 939:main.c        ****     uint8_t storedSerial[5];
 940:main.c        ****     for (int i = 0; i < userNum; i++) {
 1973               		.loc 1 940 0
 1974 06e6 10E0      		ldi r17,0
 1975 06e8 00E0      		ldi r16,0
 1976 06ea E82E      		mov r14,r24
 1977 06ec F12C      		mov r15,__zero_reg__
 1978               	.LVL210:
 1979               	.L96:
 1980               		.loc 1 940 0 is_stmt 0 discriminator 1
 1981 06ee 0E15      		cp r16,r14
 1982 06f0 1F05      		cpc r17,r15
 1983 06f2 04F0      		brlt .L98
 1984               	.LBE427:
 941:main.c        ****         eeprom_read_block(storedSerial, storedIDs[i], 5);
 942:main.c        ****         if (memcmp(serial, storedSerial, 5) == 0) {
 943:main.c        ****             return 1;
 944:main.c        ****         }
 945:main.c        ****     }
 946:main.c        ****     return 0;
 1985               		.loc 1 946 0 is_stmt 1
 1986 06f4 80E0      		ldi r24,0
 1987               	.L95:
 1988               	/* epilogue start */
 947:main.c        **** }
 1989               		.loc 1 947 0
 1990 06f6 0F90      		pop __tmp_reg__
 1991 06f8 0F90      		pop __tmp_reg__
 1992 06fa 0F90      		pop __tmp_reg__
 1993 06fc 0F90      		pop __tmp_reg__
 1994 06fe 0F90      		pop __tmp_reg__
 1995 0700 DF91      		pop r29
 1996 0702 CF91      		pop r28
 1997 0704 1F91      		pop r17
 1998 0706 0F91      		pop r16
 1999               	.LVL211:
 2000 0708 FF90      		pop r15
 2001 070a EF90      		pop r14
 2002               	.LVL212:
 2003 070c DF90      		pop r13
 2004 070e CF90      		pop r12
 2005 0710 BF90      		pop r11
 2006 0712 AF90      		pop r10
 2007               	.LVL213:
 2008 0714 0895      		ret
 2009               	.LVL214:
 2010               	.L98:
 2011               	.LBB428:
 941:main.c        ****         eeprom_read_block(storedSerial, storedIDs[i], 5);
 2012               		.loc 1 941 0
 2013 0716 45E0      		ldi r20,lo8(5)
 2014 0718 50E0      		ldi r21,0
 2015 071a B601      		movw r22,r12
 2016 071c CE01      		movw r24,r28
 2017 071e 0196      		adiw r24,1
 2018 0720 0E94 0000 		call eeprom_read_block
 2019               	.LVL215:
 942:main.c        ****             return 1;
 2020               		.loc 1 942 0
 2021 0724 45E0      		ldi r20,lo8(5)
 2022 0726 50E0      		ldi r21,0
 2023 0728 BE01      		movw r22,r28
 2024 072a 6F5F      		subi r22,-1
 2025 072c 7F4F      		sbci r23,-1
 2026 072e C501      		movw r24,r10
 2027 0730 0E94 0000 		call memcmp
 2028               	.LVL216:
 2029 0734 25E0      		ldi r18,5
 2030 0736 C20E      		add r12,r18
 2031 0738 D11C      		adc r13,__zero_reg__
 2032 073a 892B      		or r24,r25
 2033 073c 01F0      		breq .L99
 940:main.c        ****         eeprom_read_block(storedSerial, storedIDs[i], 5);
 2034               		.loc 1 940 0 discriminator 2
 2035 073e 0F5F      		subi r16,-1
 2036 0740 1F4F      		sbci r17,-1
 2037               	.LVL217:
 2038 0742 00C0      		rjmp .L96
 2039               	.L99:
 943:main.c        ****         }
 2040               		.loc 1 943 0
 2041 0744 81E0      		ldi r24,lo8(1)
 2042 0746 00C0      		rjmp .L95
 2043               	.LBE428:
 2044               		.cfi_endproc
 2045               	.LFE40:
 2047               	.global	checkAdmin
 2049               	checkAdmin:
 2050               	.LFB41:
 948:main.c        **** 
 949:main.c        **** uint8_t checkAdmin(uint8_t *serial) {
 2051               		.loc 1 949 0
 2052               		.cfi_startproc
 2053               	.LVL218:
 2054               	/* prologue: function */
 2055               	/* frame size = 0 */
 2056               	/* stack size = 0 */
 2057               	.L__stack_usage = 0
 950:main.c        ****     return memcmp(serial, adminID, 5) == 0;
 2058               		.loc 1 950 0
 2059 0748 45E0      		ldi r20,lo8(5)
 2060 074a 50E0      		ldi r21,0
 2061 074c 60E0      		ldi r22,lo8(adminID)
 2062 074e 70E0      		ldi r23,hi8(adminID)
 2063 0750 0E94 0000 		call memcmp
 2064               	.LVL219:
 2065 0754 21E0      		ldi r18,lo8(1)
 2066 0756 892B      		or r24,r25
 2067 0758 01F0      		breq .L101
 2068 075a 20E0      		ldi r18,0
 2069               	.L101:
 951:main.c        **** }
 2070               		.loc 1 951 0
 2071 075c 822F      		mov r24,r18
 2072               	/* epilogue start */
 2073 075e 0895      		ret
 2074               		.cfi_endproc
 2075               	.LFE41:
 2077               	.global	isButtonPressed
 2079               	isButtonPressed:
 2080               	.LFB42:
 952:main.c        **** 
 953:main.c        **** int8_t isButtonPressed(uint8_t button_pin, uint8_t port) {
 2081               		.loc 1 953 0
 2082               		.cfi_startproc
 2083               	.LVL220:
 2084               	/* prologue: function */
 2085               	/* frame size = 0 */
 2086               	/* stack size = 0 */
 2087               	.L__stack_usage = 0
 954:main.c        ****     static uint8_t previousState = 1;  // Keeps track of the previous button state (unpressed)
 955:main.c        ****     uint8_t currentState;
 956:main.c        **** 
 957:main.c        ****     // Check if the button is connected to PORTB or PORTC
 958:main.c        ****     if (port == 'B') {
 2088               		.loc 1 958 0
 2089 0760 6234      		cpi r22,lo8(66)
 2090 0762 01F4      		brne .L106
 959:main.c        ****         currentState = (PINB & (1 << button_pin)) ? 1 : 0;  // For buttons on PORTB
 2091               		.loc 1 959 0
 2092 0764 23B1      		in r18,0x3
 2093               	.L112:
 960:main.c        ****     } else if (port == 'C') {
 961:main.c        ****         currentState = (PINC & (1 << button_pin)) ? 1 : 0;  // For buttons on PORTC
 2094               		.loc 1 961 0
 2095 0766 30E0      		ldi r19,0
 2096 0768 00C0      		rjmp 2f
 2097               		1:
 2098 076a 3595      		asr r19
 2099 076c 2795      		ror r18
 2100               		2:
 2101 076e 8A95      		dec r24
 2102 0770 02F4      		brpl 1b
 2103 0772 922F      		mov r25,r18
 2104 0774 9170      		andi r25,lo8(1)
 2105               	.LVL221:
 2106               	.L107:
 962:main.c        ****     }
 963:main.c        **** 
 964:main.c        ****     // Detect a falling edge (button press)
 965:main.c        ****     if (previousState == 1 && currentState == 0) {
 2107               		.loc 1 965 0
 2108 0776 8091 0000 		lds r24,previousState.2282
 2109               	.LVL222:
 2110 077a 8130      		cpi r24,lo8(1)
 2111 077c 01F4      		brne .L108
 2112               		.loc 1 965 0 is_stmt 0 discriminator 1
 2113 077e 9111      		cpse r25,__zero_reg__
 2114 0780 00C0      		rjmp .L109
 2115               	.LVL223:
 2116               	.LBB429:
 2117               	.LBB430:
 187:/usr/lib/avr/include/util/delay.h **** 
 2118               		.loc 2 187 0 is_stmt 1
 2119 0782 8FE3      		ldi r24,lo8(-25537)
 2120 0784 9CE9      		ldi r25,hi8(-25537)
 2121 0786 0197      	1:	sbiw r24,1
 2122 0788 01F4      		brne 1b
 2123 078a 00C0      		rjmp .
 2124 078c 0000      		nop
 2125               	.LVL224:
 2126               	.LBE430:
 2127               	.LBE429:
 966:main.c        ****         _delay_ms(10);  // Debouncing delay
 967:main.c        ****         if (currentState == 0) {  // Check if the button is still pressed
 968:main.c        ****             previousState = 0;  // Update previous state to pressed
 2128               		.loc 1 968 0
 2129 078e 1092 0000 		sts previousState.2282,__zero_reg__
 969:main.c        ****             return 1;  // Button was pressed
 2130               		.loc 1 969 0
 2131 0792 81E0      		ldi r24,lo8(1)
 2132 0794 0895      		ret
 2133               	.LVL225:
 2134               	.L106:
 960:main.c        ****         currentState = (PINC & (1 << button_pin)) ? 1 : 0;  // For buttons on PORTC
 2135               		.loc 1 960 0
 2136 0796 6334      		cpi r22,lo8(67)
 2137 0798 01F4      		brne .L107
 961:main.c        ****     }
 2138               		.loc 1 961 0
 2139 079a 26B1      		in r18,0x6
 2140 079c 00C0      		rjmp .L112
 2141               	.LVL226:
 2142               	.L108:
 970:main.c        ****         }
 971:main.c        ****     } else if (currentState == 1) {
 2143               		.loc 1 971 0
 2144 079e 9130      		cpi r25,lo8(1)
 2145 07a0 01F4      		brne .L111
 2146               	.L109:
 972:main.c        ****         previousState = 1;  // Button is unpressed
 2147               		.loc 1 972 0
 2148 07a2 81E0      		ldi r24,lo8(1)
 2149 07a4 8093 0000 		sts previousState.2282,r24
 2150               	.L111:
 973:main.c        ****     }
 974:main.c        **** 
 975:main.c        ****     return 0;  // Button is not pressed
 2151               		.loc 1 975 0
 2152 07a8 80E0      		ldi r24,0
 2153               	/* epilogue start */
 976:main.c        **** }
 2154               		.loc 1 976 0
 2155 07aa 0895      		ret
 2156               		.cfi_endproc
 2157               	.LFE42:
 2159               	.global	resetEEPROM
 2161               	resetEEPROM:
 2162               	.LFB43:
 977:main.c        **** 
 978:main.c        **** void resetEEPROM(void) {
 2163               		.loc 1 978 0
 2164               		.cfi_startproc
 2165 07ac DF92      		push r13
 2166               	.LCFI80:
 2167               		.cfi_def_cfa_offset 3
 2168               		.cfi_offset 13, -2
 2169 07ae EF92      		push r14
 2170               	.LCFI81:
 2171               		.cfi_def_cfa_offset 4
 2172               		.cfi_offset 14, -3
 2173 07b0 FF92      		push r15
 2174               	.LCFI82:
 2175               		.cfi_def_cfa_offset 5
 2176               		.cfi_offset 15, -4
 2177 07b2 0F93      		push r16
 2178               	.LCFI83:
 2179               		.cfi_def_cfa_offset 6
 2180               		.cfi_offset 16, -5
 2181 07b4 1F93      		push r17
 2182               	.LCFI84:
 2183               		.cfi_def_cfa_offset 7
 2184               		.cfi_offset 17, -6
 2185 07b6 CF93      		push r28
 2186               	.LCFI85:
 2187               		.cfi_def_cfa_offset 8
 2188               		.cfi_offset 28, -7
 2189 07b8 DF93      		push r29
 2190               	.LCFI86:
 2191               		.cfi_def_cfa_offset 9
 2192               		.cfi_offset 29, -8
 2193 07ba 00D0      		rcall .
 2194 07bc 00D0      		rcall .
 2195 07be 1F92      		push __zero_reg__
 2196               	.LCFI87:
 2197               		.cfi_def_cfa_offset 14
 2198 07c0 CDB7      		in r28,__SP_L__
 2199 07c2 DEB7      		in r29,__SP_H__
 2200               	.LCFI88:
 2201               		.cfi_def_cfa_register 28
 2202               	/* prologue: function */
 2203               	/* frame size = 5 */
 2204               	/* stack size = 12 */
 2205               	.L__stack_usage = 12
 979:main.c        ****     // Reset the user count to 0
 980:main.c        ****     eeprom_write_byte(&userCount, 0);
 2206               		.loc 1 980 0
 2207 07c4 60E0      		ldi r22,0
 2208 07c6 80E0      		ldi r24,lo8(userCount)
 2209 07c8 90E0      		ldi r25,hi8(userCount)
 2210 07ca 0E94 0000 		call eeprom_write_byte
 2211               	.LVL227:
 2212               	.LBB431:
 2213               	.LBB432:
 187:/usr/lib/avr/include/util/delay.h **** 
 2214               		.loc 2 187 0
 2215 07ce 8FE3      		ldi r24,lo8(-25537)
 2216 07d0 9CE9      		ldi r25,hi8(-25537)
 2217 07d2 0197      	1:	sbiw r24,1
 2218 07d4 01F4      		brne 1b
 2219 07d6 00C0      		rjmp .
 2220 07d8 0000      		nop
 2221               	.LVL228:
 2222 07da 00E0      		ldi r16,lo8(storedIDs)
 2223 07dc 10E0      		ldi r17,hi8(storedIDs)
 2224               	.LBE432:
 2225               	.LBE431:
 2226               	.LBB433:
 2227               	.LBB434:
 981:main.c        ****     _delay_ms(10); // Wait for EEPROM write to complete
 982:main.c        **** 
 983:main.c        ****     // Clear all stored IDs in EEPROM
 984:main.c        ****     for (int i = 0; i < 20; i++) {
 985:main.c        ****         uint8_t emptyID[5] = {0, 0, 0, 0, 0};
 2228               		.loc 1 985 0
 2229 07de 85E0      		ldi r24,lo8(5)
 2230 07e0 D82E      		mov r13,r24
 2231 07e2 FE01      		movw r30,r28
 2232 07e4 3196      		adiw r30,1
 2233 07e6 7F01      		movw r14,r30
 2234               	.LVL229:
 2235               	.L114:
 2236               		.loc 1 985 0 is_stmt 0 discriminator 3
 2237 07e8 F701      		movw r30,r14
 2238 07ea 8D2D      		mov r24,r13
 2239               		0:
 2240 07ec 1192      		st Z+,__zero_reg__
 2241 07ee 8A95      		dec r24
 2242 07f0 01F4      		brne 0b
 986:main.c        ****         eeprom_write_block(emptyID, storedIDs[i], 5);
 2243               		.loc 1 986 0 is_stmt 1 discriminator 3
 2244 07f2 45E0      		ldi r20,lo8(5)
 2245 07f4 50E0      		ldi r21,0
 2246 07f6 B801      		movw r22,r16
 2247 07f8 C701      		movw r24,r14
 2248 07fa 0E94 0000 		call eeprom_write_block
 2249               	.LVL230:
 2250               	.LBB435:
 2251               	.LBB436:
 187:/usr/lib/avr/include/util/delay.h **** 
 2252               		.loc 2 187 0 discriminator 3
 2253 07fe EFE3      		ldi r30,lo8(-25537)
 2254 0800 FCE9      		ldi r31,hi8(-25537)
 2255 0802 3197      	1:	sbiw r30,1
 2256 0804 01F4      		brne 1b
 2257 0806 00C0      		rjmp .
 2258 0808 0000      		nop
 2259               	.LVL231:
 2260 080a 0B5F      		subi r16,-5
 2261 080c 1F4F      		sbci r17,-1
 2262               	.LBE436:
 2263               	.LBE435:
 2264               	.LBE434:
 984:main.c        ****         uint8_t emptyID[5] = {0, 0, 0, 0, 0};
 2265               		.loc 1 984 0 discriminator 3
 2266 080e F0E0      		ldi r31,hi8(storedIDs+100)
 2267 0810 0030      		cpi r16,lo8(storedIDs+100)
 2268 0812 1F07      		cpc r17,r31
 2269 0814 01F4      		brne .L114
 2270               	.LBE433:
 987:main.c        ****         _delay_ms(10); // Wait for EEPROM write to complete
 988:main.c        ****     }
 989:main.c        ****     // Reset vote counts
 990:main.c        ****     voteA = 0;
 2271               		.loc 1 990 0
 2272 0816 1092 0000 		sts voteA,__zero_reg__
 991:main.c        ****     voteB = 0;
 2273               		.loc 1 991 0
 2274 081a 1092 0000 		sts voteB,__zero_reg__
 992:main.c        ****     voteC = 0;
 2275               		.loc 1 992 0
 2276 081e 1092 0000 		sts voteC,__zero_reg__
 993:main.c        ****     voteD = 0;
 2277               		.loc 1 993 0
 2278 0822 1092 0000 		sts voteD,__zero_reg__
 2279               	.LVL232:
 2280 0826 E0E0      		ldi r30,lo8(votedUsers)
 2281 0828 F0E0      		ldi r31,hi8(votedUsers)
 2282               	.LVL233:
 2283               	.L115:
 2284               	.LBB437:
 994:main.c        **** 
 995:main.c        ****     // Optionally reset the votedUsers array (if stored in EEPROM)
 996:main.c        ****     for (int i = 0; i < 20; i++) {
 997:main.c        ****         votedUsers[i] = 0;  // Reset in RAM
 2285               		.loc 1 997 0 discriminator 3
 2286 082a 1192      		st Z+,__zero_reg__
 2287               	.LVL234:
 2288               	.LBB438:
 2289               	.LBB439:
 187:/usr/lib/avr/include/util/delay.h **** 
 2290               		.loc 2 187 0 discriminator 3
 2291 082c 8FE3      		ldi r24,lo8(-25537)
 2292 082e 9CE9      		ldi r25,hi8(-25537)
 2293 0830 0197      	1:	sbiw r24,1
 2294 0832 01F4      		brne 1b
 2295 0834 00C0      		rjmp .
 2296 0836 0000      		nop
 2297               	.LVL235:
 2298               	.LBE439:
 2299               	.LBE438:
 996:main.c        ****         votedUsers[i] = 0;  // Reset in RAM
 2300               		.loc 1 996 0 discriminator 3
 2301 0838 90E0      		ldi r25,hi8(votedUsers+20)
 2302 083a E030      		cpi r30,lo8(votedUsers+20)
 2303 083c F907      		cpc r31,r25
 2304 083e 01F4      		brne .L115
 2305               	/* epilogue start */
 2306               	.LBE437:
 998:main.c        ****         // If you store votedUsers in EEPROM, add EEPROM persistence here:
 999:main.c        ****         // eeprom_write_byte(&votedUsers[i], 0);
1000:main.c        ****         _delay_ms(10); // Wait for EEPROM write to complete
1001:main.c        ****     }
1002:main.c        **** }
 2307               		.loc 1 1002 0
 2308 0840 0F90      		pop __tmp_reg__
 2309 0842 0F90      		pop __tmp_reg__
 2310 0844 0F90      		pop __tmp_reg__
 2311 0846 0F90      		pop __tmp_reg__
 2312 0848 0F90      		pop __tmp_reg__
 2313 084a DF91      		pop r29
 2314 084c CF91      		pop r28
 2315 084e 1F91      		pop r17
 2316 0850 0F91      		pop r16
 2317 0852 FF90      		pop r15
 2318 0854 EF90      		pop r14
 2319 0856 DF90      		pop r13
 2320 0858 0895      		ret
 2321               		.cfi_endproc
 2322               	.LFE43:
 2324               		.section	.rodata.str1.1
 2325               	.LC1:
 2326 0011 456C 6563 		.string	"Electronic Voting Machine"
 2326      7472 6F6E 
 2326      6963 2056 
 2326      6F74 696E 
 2326      6720 4D61 
 2327               	.LC2:
 2328 002b 5072 6573 		.string	"Press register"
 2328      7320 7265 
 2328      6769 7374 
 2328      6572 00
 2329               	.LC3:
 2330 003a 5461 7020 		.string	"Tap Admin ID"
 2330      4164 6D69 
 2330      6E20 4944 
 2330      00
 2331               	.LC4:
 2332 0047 4164 6D69 		.string	"Admin Verified"
 2332      6E20 5665 
 2332      7269 6669 
 2332      6564 00
 2333               	.LC5:
 2334 0056 506C 6561 		.string	"Please wait"
 2334      7365 2077 
 2334      6169 7400 
 2335               	.LC6:
 2336 0062 5379 7374 		.string	"System Reseted"
 2336      656D 2052 
 2336      6573 6574 
 2336      6564 00
 2337               	.LC7:
 2338 0071 5375 6363 		.string	"Successfully"
 2338      6573 7366 
 2338      756C 6C79 
 2338      00
 2339               	.LC8:
 2340 007e 4175 7468 		.string	"Auth Failed"
 2340      2046 6169 
 2340      6C65 6400 
 2341               	.LC9:
 2342 008a 2020 413A 		.string	"  A:%d      B:%d"
 2342      2564 2020 
 2342      2020 2020 
 2342      423A 2564 
 2342      00
 2343               	.LC10:
 2344 009b 2020 433A 		.string	"  C:%d      D:%d"
 2344      2564 2020 
 2344      2020 2020 
 2344      443A 2564 
 2344      00
 2345               	.LC11:
 2346 00ac 5265 6769 		.string	"Registered :%d"
 2346      7374 6572 
 2346      6564 203A 
 2346      2564 00
 2347               	.LC12:
 2348 00bb 566F 7465 		.string	"Voted :%d"
 2348      6420 3A25 
 2348      6400 
 2349               	.LC13:
 2350 00c5 4E6F 2052 		.string	"No Results"
 2350      6573 756C 
 2350      7473 00
 2351               	.LC14:
 2352 00d0 546F 2044 		.string	"To Display"
 2352      6973 706C 
 2352      6179 00
 2353               	.LC15:
 2354 00db 5461 7020 		.string	"Tap Admin RFID"
 2354      4164 6D69 
 2354      6E20 5246 
 2354      4944 00
 2355               	.LC16:
 2356 00ea 5265 6769 		.string	"Registration"
 2356      7374 7261 
 2356      7469 6F6E 
 2356      00
 2357               	.LC17:
 2358 00f7 5461 7020 		.string	"Tap your RFID"
 2358      796F 7572 
 2358      2052 4649 
 2358      4400 
 2359               	.LC18:
 2360 0105 5375 6363 		.string	"Successful"
 2360      6573 7366 
 2360      756C 00
 2361               	.LC19:
 2362 0110 416C 7265 		.string	"Already"
 2362      6164 7900 
 2363               	.LC20:
 2364 0118 5265 6769 		.string	"Registered"
 2364      7374 6572 
 2364      6564 00
 2365               	.LC21:
 2366 0123 5472 7920 		.string	"Try again"
 2366      6167 6169 
 2366      6E00 
 2367               	.LC22:
 2368 012d 4E6F 2056 		.string	"No Voters"
 2368      6F74 6572 
 2368      7300 
 2369               	.LC23:
 2370 0137 5265 6769 		.string	"Register first"
 2370      7374 6572 
 2370      2066 6972 
 2370      7374 00
 2371               	.LC24:
 2372 0146 546F 2056 		.string	"To Vote"
 2372      6F74 6500 
 2373               	.LC25:
 2374 014e 506C 6561 		.string	"Please vote"
 2374      7365 2076 
 2374      6F74 6500 
 2375               	.LC26:
 2376 015a 5468 616E 		.string	"Thank for voting"
 2376      6B20 666F 
 2376      7220 766F 
 2376      7469 6E67 
 2376      00
 2377               	.LC27:
 2378 016b 416C 7265 		.string	"Already voted"
 2378      6164 7920 
 2378      766F 7465 
 2378      6400 
 2379               	.LC28:
 2380 0179 496E 7661 		.string	"Invalid Vote"
 2380      6C69 6420 
 2380      566F 7465 
 2380      00
 2381               		.section	.text.startup,"ax",@progbits
 2382               	.global	main
 2384               	main:
 2385               	.LFB10:
 121:main.c        ****         uint8_t serial[5];
 2386               		.loc 1 121 0
 2387               		.cfi_startproc
 2388 0000 CF93      		push r28
 2389               	.LCFI89:
 2390               		.cfi_def_cfa_offset 3
 2391               		.cfi_offset 28, -2
 2392 0002 DF93      		push r29
 2393               	.LCFI90:
 2394               		.cfi_def_cfa_offset 4
 2395               		.cfi_offset 29, -3
 2396 0004 CDB7      		in r28,__SP_L__
 2397 0006 DEB7      		in r29,__SP_H__
 2398               	.LCFI91:
 2399               		.cfi_def_cfa_register 28
 2400 0008 C754      		subi r28,71
 2401 000a D109      		sbc r29,__zero_reg__
 2402               	.LCFI92:
 2403               		.cfi_def_cfa_offset 75
 2404 000c 0FB6      		in __tmp_reg__,__SREG__
 2405 000e F894      		cli
 2406 0010 DEBF      		out __SP_H__,r29
 2407 0012 0FBE      		out __SREG__,__tmp_reg__
 2408 0014 CDBF      		out __SP_L__,r28
 2409               	/* prologue: function */
 2410               	/* frame size = 71 */
 2411               	/* stack size = 73 */
 2412               	.L__stack_usage = 73
 125:main.c        **** 
 2413               		.loc 1 125 0
 2414 0016 2796      		adiw r28,70-63
 2415 0018 1FAE      		std Y+63,__zero_reg__
 2416 001a 2797      		sbiw r28,70-63
 127:main.c        ****     	initLEDs_Buzzer(); // Initialize both LEDs	
 2417               		.loc 1 127 0
 2418 001c 0E94 0000 		call initSPI
 2419               	.LVL236:
 128:main.c        ****     	MFRC522_init();
 2420               		.loc 1 128 0
 2421 0020 0E94 0000 		call initLEDs_Buzzer
 2422               	.LVL237:
 129:main.c        ****     	i2c_init();  // Initialize I2C communication for LCD:
 2423               		.loc 1 129 0
 2424 0024 0E94 0000 		call MFRC522_init
 2425               	.LVL238:
 130:main.c        ****     	LCD_Init();
 2426               		.loc 1 130 0
 2427 0028 0E94 0000 		call i2c_init
 2428               	.LVL239:
 131:main.c        ****     	initButton(); 
 2429               		.loc 1 131 0
 2430 002c 0E94 0000 		call LCD_Init
 2431               	.LVL240:
 132:main.c        ****         blinkLED_Buzzer(LED_PIN_Vote);
 2432               		.loc 1 132 0
 2433 0030 0E94 0000 		call initButton
 2434               	.LVL241:
 133:main.c        **** 	// Main loop: Scrolling display until register is pressed
 2435               		.loc 1 133 0
 2436 0034 85E0      		ldi r24,lo8(5)
 2437 0036 0E94 0000 		call blinkLED_Buzzer
 2438               	.LVL242:
 2439               	.LBB440:
 2440               	.LBB441:
 2441               	.LBB442:
 2442               	.LBB443:
 222:main.c        ****                                 LCD_Print(resultMsg1);
 2443               		.loc 1 222 0
 2444 003a 50E1      		ldi r21,lo8(16)
 2445 003c 752E      		mov r7,r21
 2446 003e 8E01      		movw r16,r28
 2447 0040 0F5C      		subi r16,-49
 2448 0042 1F4F      		sbci r17,-1
 226:main.c        ****                                 LCD_Print(resultMsg2);
 2449               		.loc 1 226 0
 2450 0044 7E01      		movw r14,r28
 2451 0046 21E2      		ldi r18,33
 2452 0048 E20E      		add r14,r18
 2453 004a F11C      		adc r15,__zero_reg__
 234:main.c        ****                                 LCD_Print(regMsg);
 2454               		.loc 1 234 0
 2455 004c 60E0      		ldi r22,lo8(.LC11)
 2456 004e 262E      		mov r2,r22
 2457 0050 60E0      		ldi r22,hi8(.LC11)
 2458 0052 362E      		mov r3,r22
 2459 0054 6E01      		movw r12,r28
 2460 0056 31E1      		ldi r19,17
 2461 0058 C30E      		add r12,r19
 2462 005a D11C      		adc r13,__zero_reg__
 238:main.c        ****                                 LCD_Print(votedMsg);
 2463               		.loc 1 238 0
 2464 005c 70E0      		ldi r23,lo8(.LC12)
 2465 005e 472E      		mov r4,r23
 2466 0060 70E0      		ldi r23,hi8(.LC12)
 2467 0062 572E      		mov r5,r23
 2468 0064 CE01      		movw r24,r28
 2469 0066 0196      		adiw r24,1
 2470 0068 5C01      		movw r10,r24
 2471               	.L119:
 2472               	.LBE443:
 2473               	.LBE442:
 2474               	.LBE441:
 2475               	.LBE440:
 138:main.c        ****         LCD_SetPosition(1, 0);  // Fixed message on second line
 2476               		.loc 1 138 0
 2477 006a 9E01      		movw r18,r28
 2478 006c 2A5B      		subi r18,-70
 2479 006e 3F4F      		sbci r19,-1
 2480 0070 41E0      		ldi r20,lo8(1)
 2481 0072 60E0      		ldi r22,0
 2482 0074 80E0      		ldi r24,lo8(.LC1)
 2483 0076 90E0      		ldi r25,hi8(.LC1)
 2484 0078 0E94 0000 		call LCD_ScrollText
 2485               	.LVL243:
 2486               	.LBB482:
 2487               	.LBB483:
 883:main.c        **** }
 2488               		.loc 1 883 0
 2489 007c 80EC      		ldi r24,lo8(-64)
 2490 007e 0E94 0000 		call LCD_SendCommand
 2491               	.LVL244:
 2492               	.LBE483:
 2493               	.LBE482:
 140:main.c        ****         
 2494               		.loc 1 140 0
 2495 0082 80E0      		ldi r24,lo8(.LC2)
 2496 0084 90E0      		ldi r25,hi8(.LC2)
 2497 0086 0E94 0000 		call LCD_Print
 2498               	.LVL245:
 143:main.c        ****             blinkLED_Buzzer(LED_PIN_RR);
 2499               		.loc 1 143 0
 2500 008a 62E4      		ldi r22,lo8(66)
 2501 008c 87E0      		ldi r24,lo8(7)
 2502 008e 0E94 0000 		call isButtonPressed
 2503               	.LVL246:
 2504 0092 8823      		tst r24
 2505 0094 01F4      		brne .+2
 2506 0096 00C0      		rjmp .L123
 2507               	.LVL247:
 2508               	.LBB484:
 2509               	.LBB485:
 2510               	.LBB486:
 2511 0098 0E94 0000 		call blinkLED_Buzzer.part.2
 2512               	.LVL248:
 2513               	.LBE486:
 2514               	.LBE485:
 145:main.c        ****             LCD_SetPosition(0, 0);
 2515               		.loc 1 145 0
 2516 009c 0E94 0000 		call LCD_Clear
 2517               	.LVL249:
 2518               	.LBB487:
 2519               	.LBB488:
 883:main.c        **** }
 2520               		.loc 1 883 0
 2521 00a0 80E8      		ldi r24,lo8(-128)
 2522 00a2 0E94 0000 		call LCD_SendCommand
 2523               	.LVL250:
 2524               	.LBE488:
 2525               	.LBE487:
 147:main.c        **** 
 2526               		.loc 1 147 0
 2527 00a6 80E0      		ldi r24,lo8(.LC3)
 2528 00a8 90E0      		ldi r25,hi8(.LC3)
 2529 00aa 0E94 0000 		call LCD_Print
 2530               	.LVL251:
 2531 00ae 44E6      		ldi r20,lo8(100)
 2532 00b0 842E      		mov r8,r20
 2533 00b2 912C      		mov r9,__zero_reg__
 2534               	.LVL252:
 2535               	.L124:
 154:main.c        ****                 if (status == MI_OK && MFRC522_anticoll(serial) == MI_OK) {
 2536               		.loc 1 154 0
 2537 00b4 BE01      		movw r22,r28
 2538 00b6 6F5B      		subi r22,-65
 2539 00b8 7F4F      		sbci r23,-1
 2540 00ba 86E2      		ldi r24,lo8(38)
 2541 00bc 0E94 0000 		call MFRC522_request
 2542               	.LVL253:
 155:main.c        ****                     if (checkAdmin(serial)) {
 2543               		.loc 1 155 0
 2544 00c0 8111      		cpse r24,__zero_reg__
 2545 00c2 00C0      		rjmp .L121
 155:main.c        ****                     if (checkAdmin(serial)) {
 2546               		.loc 1 155 0 is_stmt 0 discriminator 1
 2547 00c4 CE01      		movw r24,r28
 2548               	.LVL254:
 2549 00c6 8F5B      		subi r24,-65
 2550 00c8 9F4F      		sbci r25,-1
 2551 00ca 0E94 0000 		call MFRC522_anticoll
 2552               	.LVL255:
 2553 00ce 8111      		cpse r24,__zero_reg__
 2554 00d0 00C0      		rjmp .L121
 156:main.c        ****                         // Admin verified, reset EEPROM
 2555               		.loc 1 156 0 is_stmt 1
 2556 00d2 CE01      		movw r24,r28
 2557 00d4 8F5B      		subi r24,-65
 2558 00d6 9F4F      		sbci r25,-1
 2559 00d8 0E94 0000 		call checkAdmin
 2560               	.LVL256:
 2561 00dc 8823      		tst r24
 2562 00de 01F4      		brne .+2
 2563 00e0 00C0      		rjmp .L122
 158:main.c        ****                         LCD_SetPosition(0, 0);
 2564               		.loc 1 158 0
 2565 00e2 0E94 0000 		call LCD_Clear
 2566               	.LVL257:
 2567               	.LBB489:
 2568               	.LBB490:
 883:main.c        **** }
 2569               		.loc 1 883 0
 2570 00e6 80E8      		ldi r24,lo8(-128)
 2571 00e8 0E94 0000 		call LCD_SendCommand
 2572               	.LVL258:
 2573               	.LBE490:
 2574               	.LBE489:
 160:main.c        ****                         blinkLED_Buzzer(LED_PIN_RR);
 2575               		.loc 1 160 0
 2576 00ec 80E0      		ldi r24,lo8(.LC4)
 2577 00ee 90E0      		ldi r25,hi8(.LC4)
 2578 00f0 0E94 0000 		call LCD_Print
 2579               	.LVL259:
 2580               	.LBB491:
 2581               	.LBB492:
 2582 00f4 0E94 0000 		call blinkLED_Buzzer.part.2
 2583               	.LVL260:
 2584               	.LBE492:
 2585               	.LBE491:
 2586               	.LBB493:
 2587               	.LBB494:
 187:/usr/lib/avr/include/util/delay.h **** 
 2588               		.loc 2 187 0
 2589 00f8 9FEF      		ldi r25,lo8(159999)
 2590 00fa E0E7      		ldi r30,hi8(159999)
 2591 00fc F2E0      		ldi r31,hlo8(159999)
 2592 00fe 9150      	1:	subi r25,1
 2593 0100 E040      		sbci r30,0
 2594 0102 F040      		sbci r31,0
 2595 0104 01F4      		brne 1b
 2596 0106 00C0      		rjmp .
 2597 0108 0000      		nop
 2598               	.LVL261:
 2599               	.LBE494:
 2600               	.LBE493:
 164:main.c        ****                         LCD_SetPosition(0, 0);
 2601               		.loc 1 164 0
 2602 010a 0E94 0000 		call LCD_Clear
 2603               	.LVL262:
 2604               	.LBB495:
 2605               	.LBB496:
 883:main.c        **** }
 2606               		.loc 1 883 0
 2607 010e 80E8      		ldi r24,lo8(-128)
 2608 0110 0E94 0000 		call LCD_SendCommand
 2609               	.LVL263:
 2610               	.LBE496:
 2611               	.LBE495:
 166:main.c        ****                         resetEEPROM();  // Clear EEPROM after Admin verification
 2612               		.loc 1 166 0
 2613 0114 80E0      		ldi r24,lo8(.LC5)
 2614 0116 90E0      		ldi r25,hi8(.LC5)
 2615 0118 0E94 0000 		call LCD_Print
 2616               	.LVL264:
 167:main.c        ****                         LCD_Clear();
 2617               		.loc 1 167 0
 2618 011c 0E94 0000 		call resetEEPROM
 2619               	.LVL265:
 168:main.c        ****                         LCD_SetPosition(0, 0);
 2620               		.loc 1 168 0
 2621 0120 0E94 0000 		call LCD_Clear
 2622               	.LVL266:
 2623               	.LBB497:
 2624               	.LBB498:
 883:main.c        **** }
 2625               		.loc 1 883 0
 2626 0124 80E8      		ldi r24,lo8(-128)
 2627 0126 0E94 0000 		call LCD_SendCommand
 2628               	.LVL267:
 2629               	.LBE498:
 2630               	.LBE497:
 170:main.c        ****                         LCD_SetPosition(1, 0);
 2631               		.loc 1 170 0
 2632 012a 80E0      		ldi r24,lo8(.LC6)
 2633 012c 90E0      		ldi r25,hi8(.LC6)
 2634 012e 0E94 0000 		call LCD_Print
 2635               	.LVL268:
 2636               	.LBB499:
 2637               	.LBB500:
 883:main.c        **** }
 2638               		.loc 1 883 0
 2639 0132 80EC      		ldi r24,lo8(-64)
 2640 0134 0E94 0000 		call LCD_SendCommand
 2641               	.LVL269:
 2642               	.LBE500:
 2643               	.LBE499:
 172:main.c        ****                         blinkLED_Buzzer(LED_PIN_RR);
 2644               		.loc 1 172 0
 2645 0138 80E0      		ldi r24,lo8(.LC7)
 2646 013a 90E0      		ldi r25,hi8(.LC7)
 2647 013c 0E94 0000 		call LCD_Print
 2648               	.LVL270:
 2649               	.LBB501:
 2650               	.LBB502:
 2651 0140 0E94 0000 		call blinkLED_Buzzer.part.2
 2652               	.LVL271:
 2653               	.LBE502:
 2654               	.LBE501:
 2655               	.LBB503:
 2656               	.LBB504:
 187:/usr/lib/avr/include/util/delay.h **** 
 2657               		.loc 2 187 0
 2658 0144 2FEF      		ldi r18,lo8(159999)
 2659 0146 30E7      		ldi r19,hi8(159999)
 2660 0148 82E0      		ldi r24,hlo8(159999)
 2661 014a 2150      	1:	subi r18,1
 2662 014c 3040      		sbci r19,0
 2663 014e 8040      		sbci r24,0
 2664 0150 01F4      		brne 1b
 2665               	.LVL272:
 2666               	.L193:
 2667               	.LBE504:
 2668               	.LBE503:
 2669               	.LBB505:
 2670               	.LBB506:
 2671 0152 00C0      		rjmp .
 2672 0154 0000      		nop
 2673               	.LVL273:
 2674               	.L123:
 2675               	.LBE506:
 2676               	.LBE505:
 2677               	.LBE484:
 194:main.c        ****             uint8_t totalVoted = voteA + voteB + voteC + voteD;
 2678               		.loc 1 194 0
 2679 0156 62E4      		ldi r22,lo8(66)
 2680 0158 86E0      		ldi r24,lo8(6)
 2681 015a 0E94 0000 		call isButtonPressed
 2682               	.LVL274:
 2683 015e 8823      		tst r24
 2684 0160 01F4      		brne .+2
 2685 0162 00C0      		rjmp .L126
 2686               	.LBB515:
 195:main.c        ****             if (totalVoted > 0) {
 2687               		.loc 1 195 0
 2688 0164 6090 0000 		lds r6,voteA
 2689 0168 8091 0000 		lds r24,voteB
 2690 016c 680E      		add r6,r24
 2691 016e 8091 0000 		lds r24,voteC
 2692 0172 680E      		add r6,r24
 2693 0174 8091 0000 		lds r24,voteD
 2694 0178 680E      		add r6,r24
 2695               	.LVL275:
 196:main.c        ****                 // Admin authentication for displaying result
 2696               		.loc 1 196 0
 2697 017a 01F4      		brne .+2
 2698 017c 00C0      		rjmp .L127
 2699               	.LVL276:
 2700               	.LBB472:
 2701               	.LBB459:
 2702               	.LBB460:
 2703 017e 0E94 0000 		call blinkLED_Buzzer.part.2
 2704               	.LVL277:
 2705               	.LBE460:
 2706               	.LBE459:
 199:main.c        ****                 LCD_SetPosition(0, 0);
 2707               		.loc 1 199 0
 2708 0182 0E94 0000 		call LCD_Clear
 2709               	.LVL278:
 2710               	.LBB461:
 2711               	.LBB462:
 883:main.c        **** }
 2712               		.loc 1 883 0
 2713 0186 80E8      		ldi r24,lo8(-128)
 2714 0188 0E94 0000 		call LCD_SendCommand
 2715               	.LVL279:
 2716               	.LBE462:
 2717               	.LBE461:
 201:main.c        **** 
 2718               		.loc 1 201 0
 2719 018c 80E0      		ldi r24,lo8(.LC3)
 2720 018e 90E0      		ldi r25,hi8(.LC3)
 2721 0190 0E94 0000 		call LCD_Print
 2722               	.LVL280:
 2723 0194 32E3      		ldi r19,lo8(50)
 2724 0196 832E      		mov r8,r19
 2725 0198 912C      		mov r9,__zero_reg__
 2726               	.LVL281:
 2727               	.L131:
 208:main.c        ****                     if (status == MI_OK && MFRC522_anticoll(serial) == MI_OK) {
 2728               		.loc 1 208 0
 2729 019a BE01      		movw r22,r28
 2730 019c 6F5B      		subi r22,-65
 2731 019e 7F4F      		sbci r23,-1
 2732 01a0 86E2      		ldi r24,lo8(38)
 2733 01a2 0E94 0000 		call MFRC522_request
 2734               	.LVL282:
 209:main.c        ****                         if (checkAdmin(serial)) {
 2735               		.loc 1 209 0
 2736 01a6 8111      		cpse r24,__zero_reg__
 2737 01a8 00C0      		rjmp .L128
 209:main.c        ****                         if (checkAdmin(serial)) {
 2738               		.loc 1 209 0 is_stmt 0 discriminator 1
 2739 01aa CE01      		movw r24,r28
 2740               	.LVL283:
 2741 01ac 8F5B      		subi r24,-65
 2742 01ae 9F4F      		sbci r25,-1
 2743 01b0 0E94 0000 		call MFRC522_anticoll
 2744               	.LVL284:
 2745 01b4 8111      		cpse r24,__zero_reg__
 2746 01b6 00C0      		rjmp .L128
 210:main.c        ****                             adminVerified = 1;
 2747               		.loc 1 210 0 is_stmt 1
 2748 01b8 CE01      		movw r24,r28
 2749 01ba 8F5B      		subi r24,-65
 2750 01bc 9F4F      		sbci r25,-1
 2751 01be 0E94 0000 		call checkAdmin
 2752               	.LVL285:
 2753 01c2 8823      		tst r24
 2754 01c4 01F4      		brne .+2
 2755 01c6 00C0      		rjmp .L128
 2756               	.LVL286:
 2757               	.LBB463:
 2758               	.LBB456:
 2759               	.LBB457:
 2760 01c8 0E94 0000 		call blinkLED_Buzzer.part.2
 2761               	.LVL287:
 2762 01cc 23E0      		ldi r18,lo8(3)
 2763 01ce 822E      		mov r8,r18
 2764 01d0 912C      		mov r9,__zero_reg__
 2765               	.LVL288:
 2766               	.L129:
 2767               	.LBE457:
 2768               	.LBE456:
 2769               	.LBB458:
 219:main.c        ****                                 LCD_SetPosition(0, 0);
 2770               		.loc 1 219 0
 2771 01d2 0E94 0000 		call LCD_Clear
 2772               	.LVL289:
 2773               	.LBB444:
 2774               	.LBB445:
 883:main.c        **** }
 2775               		.loc 1 883 0
 2776 01d6 80E8      		ldi r24,lo8(-128)
 2777 01d8 0E94 0000 		call LCD_SendCommand
 2778               	.LVL290:
 2779               	.LBE445:
 2780               	.LBE444:
 222:main.c        ****                                 LCD_Print(resultMsg1);
 2781               		.loc 1 222 0
 2782 01dc 8091 0000 		lds r24,voteB
 2783 01e0 1F92      		push __zero_reg__
 2784 01e2 8F93      		push r24
 2785 01e4 8091 0000 		lds r24,voteA
 2786 01e8 1F92      		push __zero_reg__
 2787 01ea 8F93      		push r24
 2788 01ec E0E0      		ldi r30,lo8(.LC9)
 2789 01ee F0E0      		ldi r31,hi8(.LC9)
 2790 01f0 FF93      		push r31
 2791 01f2 EF93      		push r30
 2792 01f4 1F92      		push __zero_reg__
 2793 01f6 7F92      		push r7
 2794 01f8 1F93      		push r17
 2795 01fa 0F93      		push r16
 2796 01fc 0E94 0000 		call snprintf
 2797               	.LVL291:
 223:main.c        ****                                 LCD_SetPosition(1, 0);
 2798               		.loc 1 223 0
 2799 0200 C801      		movw r24,r16
 2800 0202 0E94 0000 		call LCD_Print
 2801               	.LVL292:
 2802               	.LBB446:
 2803               	.LBB447:
 883:main.c        **** }
 2804               		.loc 1 883 0
 2805 0206 80EC      		ldi r24,lo8(-64)
 2806 0208 0E94 0000 		call LCD_SendCommand
 2807               	.LVL293:
 2808               	.LBE447:
 2809               	.LBE446:
 226:main.c        ****                                 LCD_Print(resultMsg2);
 2810               		.loc 1 226 0
 2811 020c 8091 0000 		lds r24,voteD
 2812 0210 1F92      		push __zero_reg__
 2813 0212 8F93      		push r24
 2814 0214 8091 0000 		lds r24,voteC
 2815 0218 1F92      		push __zero_reg__
 2816 021a 8F93      		push r24
 2817 021c 80E0      		ldi r24,lo8(.LC10)
 2818 021e 90E0      		ldi r25,hi8(.LC10)
 2819 0220 9F93      		push r25
 2820 0222 8F93      		push r24
 2821 0224 1F92      		push __zero_reg__
 2822 0226 7F92      		push r7
 2823 0228 FF92      		push r15
 2824 022a EF92      		push r14
 2825 022c 0E94 0000 		call snprintf
 2826               	.LVL294:
 227:main.c        ****                                 _delay_ms(1000);
 2827               		.loc 1 227 0
 2828 0230 C701      		movw r24,r14
 2829 0232 0E94 0000 		call LCD_Print
 2830               	.LVL295:
 2831               	.LBB448:
 2832               	.LBB449:
 187:/usr/lib/avr/include/util/delay.h **** 
 2833               		.loc 2 187 0
 2834 0236 FFEF      		ldi r31,lo8(3199999)
 2835 0238 23ED      		ldi r18,hi8(3199999)
 2836 023a 30E3      		ldi r19,hlo8(3199999)
 2837 023c F150      	1:	subi r31,1
 2838 023e 2040      		sbci r18,0
 2839 0240 3040      		sbci r19,0
 2840 0242 01F4      		brne 1b
 2841 0244 00C0      		rjmp .
 2842 0246 0000      		nop
 2843               	.LVL296:
 2844               	.LBE449:
 2845               	.LBE448:
 231:main.c        ****                                 LCD_SetPosition(0, 0);
 2846               		.loc 1 231 0
 2847 0248 0E94 0000 		call LCD_Clear
 2848               	.LVL297:
 2849               	.LBB450:
 2850               	.LBB451:
 883:main.c        **** }
 2851               		.loc 1 883 0
 2852 024c 80E8      		ldi r24,lo8(-128)
 2853 024e 0E94 0000 		call LCD_SendCommand
 2854               	.LVL298:
 2855               	.LBE451:
 2856               	.LBE450:
 234:main.c        ****                                 LCD_Print(regMsg);
 2857               		.loc 1 234 0
 2858 0252 80E0      		ldi r24,lo8(userCount)
 2859 0254 90E0      		ldi r25,hi8(userCount)
 2860 0256 0E94 0000 		call eeprom_read_byte
 2861               	.LVL299:
 2862 025a 1F92      		push __zero_reg__
 2863 025c 8F93      		push r24
 2864 025e 3F92      		push r3
 2865 0260 2F92      		push r2
 2866 0262 1F92      		push __zero_reg__
 2867 0264 7F92      		push r7
 2868 0266 DF92      		push r13
 2869 0268 CF92      		push r12
 2870 026a 0E94 0000 		call snprintf
 2871               	.LVL300:
 235:main.c        ****                                 LCD_SetPosition(1, 0);
 2872               		.loc 1 235 0
 2873 026e C601      		movw r24,r12
 2874 0270 0E94 0000 		call LCD_Print
 2875               	.LVL301:
 2876               	.LBB452:
 2877               	.LBB453:
 883:main.c        **** }
 2878               		.loc 1 883 0
 2879 0274 80EC      		ldi r24,lo8(-64)
 2880 0276 0E94 0000 		call LCD_SendCommand
 2881               	.LVL302:
 2882               	.LBE453:
 2883               	.LBE452:
 238:main.c        ****                                 LCD_Print(votedMsg);
 2884               		.loc 1 238 0
 2885 027a 1F92      		push __zero_reg__
 2886 027c 6F92      		push r6
 2887 027e 5F92      		push r5
 2888 0280 4F92      		push r4
 2889 0282 1F92      		push __zero_reg__
 2890 0284 7F92      		push r7
 2891 0286 BF92      		push r11
 2892 0288 AF92      		push r10
 2893 028a 0E94 0000 		call snprintf
 2894               	.LVL303:
 239:main.c        ****                                 _delay_ms(1000);
 2895               		.loc 1 239 0
 2896 028e 0FB6      		in __tmp_reg__,__SREG__
 2897 0290 F894      		cli
 2898 0292 DEBF      		out __SP_H__,r29
 2899 0294 0FBE      		out __SREG__,__tmp_reg__
 2900 0296 CDBF      		out __SP_L__,r28
 2901 0298 C501      		movw r24,r10
 2902 029a 0E94 0000 		call LCD_Print
 2903               	.LVL304:
 2904               	.LBB454:
 2905               	.LBB455:
 187:/usr/lib/avr/include/util/delay.h **** 
 2906               		.loc 2 187 0
 2907 029e 9FEF      		ldi r25,lo8(3199999)
 2908 02a0 E3ED      		ldi r30,hi8(3199999)
 2909 02a2 F0E3      		ldi r31,hlo8(3199999)
 2910 02a4 9150      	1:	subi r25,1
 2911 02a6 E040      		sbci r30,0
 2912 02a8 F040      		sbci r31,0
 2913 02aa 01F4      		brne 1b
 2914 02ac 00C0      		rjmp .
 2915 02ae 0000      		nop
 2916               	.LVL305:
 2917 02b0 21E0      		ldi r18,1
 2918 02b2 821A      		sub r8,r18
 2919 02b4 9108      		sbc r9,__zero_reg__
 2920               	.LVL306:
 2921               	.LBE455:
 2922               	.LBE454:
 2923               	.LBE458:
 217:main.c        ****                                 // Display the total votes for 1 second
 2924               		.loc 1 217 0
 2925 02b6 01F0      		breq .+2
 2926 02b8 00C0      		rjmp .L129
 2927               	.LVL307:
 2928               	.L126:
 2929               	.LBE463:
 2930               	.LBE472:
 2931               	.LBE515:
 273:main.c        ****             blinkLED_Buzzer(LED_PIN_Reg);
 2932               		.loc 1 273 0
 2933 02ba 62E4      		ldi r22,lo8(66)
 2934 02bc 80E0      		ldi r24,0
 2935 02be 0E94 0000 		call isButtonPressed
 2936               	.LVL308:
 2937 02c2 8823      		tst r24
 2938 02c4 01F4      		brne .+2
 2939 02c6 00C0      		rjmp .L133
 274:main.c        ****             LCD_Clear();  // Clear the screen when registration button is pressed
 2940               		.loc 1 274 0
 2941 02c8 83E0      		ldi r24,lo8(3)
 2942 02ca 0E94 0000 		call blinkLED_Buzzer
 2943               	.LVL309:
 2944               	.L195:
 275:main.c        ****             // Enter registration mode when register button is pressed
 2945               		.loc 1 275 0
 2946 02ce 0E94 0000 		call LCD_Clear
 2947               	.LVL310:
 2948               	.LBB516:
 2949               	.LBB517:
 883:main.c        **** }
 2950               		.loc 1 883 0
 2951 02d2 80E8      		ldi r24,lo8(-128)
 2952 02d4 0E94 0000 		call LCD_SendCommand
 2953               	.LVL311:
 2954               	.LBE517:
 2955               	.LBE516:
 278:main.c        ****             
 2956               		.loc 1 278 0
 2957 02d8 80E0      		ldi r24,lo8(.LC15)
 2958 02da 90E0      		ldi r25,hi8(.LC15)
 2959 02dc 0E94 0000 		call LCD_Print
 2960               	.LVL312:
 2961               	.L134:
 282:main.c        ****                 if (status == MI_OK && MFRC522_anticoll(serial) == MI_OK) {
 2962               		.loc 1 282 0
 2963 02e0 BE01      		movw r22,r28
 2964 02e2 6F5B      		subi r22,-65
 2965 02e4 7F4F      		sbci r23,-1
 2966 02e6 86E2      		ldi r24,lo8(38)
 2967 02e8 0E94 0000 		call MFRC522_request
 2968               	.LVL313:
 283:main.c        ****                     if (checkAdmin(serial)) {
 2969               		.loc 1 283 0
 2970 02ec 8111      		cpse r24,__zero_reg__
 2971 02ee 00C0      		rjmp .L134
 283:main.c        ****                     if (checkAdmin(serial)) {
 2972               		.loc 1 283 0 is_stmt 0 discriminator 1
 2973 02f0 CE01      		movw r24,r28
 2974               	.LVL314:
 2975 02f2 8F5B      		subi r24,-65
 2976 02f4 9F4F      		sbci r25,-1
 2977 02f6 0E94 0000 		call MFRC522_anticoll
 2978               	.LVL315:
 2979 02fa 8111      		cpse r24,__zero_reg__
 2980 02fc 00C0      		rjmp .L134
 284:main.c        ****                         blinkLED_Buzzer(LED_PIN_RR);
 2981               		.loc 1 284 0 is_stmt 1
 2982 02fe CE01      		movw r24,r28
 2983 0300 8F5B      		subi r24,-65
 2984 0302 9F4F      		sbci r25,-1
 2985 0304 0E94 0000 		call checkAdmin
 2986               	.LVL316:
 2987 0308 8823      		tst r24
 2988 030a 01F4      		brne .+2
 2989 030c 00C0      		rjmp .L136
 2990               	.LVL317:
 2991               	.LBB518:
 2992               	.LBB519:
 2993 030e 0E94 0000 		call blinkLED_Buzzer.part.2
 2994               	.LVL318:
 2995               	.LBE519:
 2996               	.LBE518:
 286:main.c        ****                         LCD_SetPosition(0, 0);
 2997               		.loc 1 286 0
 2998 0312 0E94 0000 		call LCD_Clear
 2999               	.LVL319:
 3000               	.LBB520:
 3001               	.LBB521:
 883:main.c        **** }
 3002               		.loc 1 883 0
 3003 0316 80E8      		ldi r24,lo8(-128)
 3004 0318 0E94 0000 		call LCD_SendCommand
 3005               	.LVL320:
 3006               	.LBE521:
 3007               	.LBE520:
 288:main.c        ****                         _delay_ms(100);
 3008               		.loc 1 288 0
 3009 031c 80E0      		ldi r24,lo8(.LC4)
 3010 031e 90E0      		ldi r25,hi8(.LC4)
 3011 0320 0E94 0000 		call LCD_Print
 3012               	.LVL321:
 3013               	.LBB522:
 3014               	.LBB523:
 187:/usr/lib/avr/include/util/delay.h **** 
 3015               		.loc 2 187 0
 3016 0324 3FEF      		ldi r19,lo8(319999)
 3017 0326 81EE      		ldi r24,hi8(319999)
 3018 0328 94E0      		ldi r25,hlo8(319999)
 3019 032a 3150      	1:	subi r19,1
 3020 032c 8040      		sbci r24,0
 3021 032e 9040      		sbci r25,0
 3022 0330 01F4      		brne 1b
 3023 0332 00C0      		rjmp .
 3024 0334 0000      		nop
 3025               	.LVL322:
 3026               	.LBE523:
 3027               	.LBE522:
 291:main.c        ****                         LCD_SetPosition(0, 0);
 3028               		.loc 1 291 0
 3029 0336 0E94 0000 		call LCD_Clear
 3030               	.LVL323:
 3031               	.LBB524:
 3032               	.LBB525:
 883:main.c        **** }
 3033               		.loc 1 883 0
 3034 033a 80E8      		ldi r24,lo8(-128)
 3035 033c 0E94 0000 		call LCD_SendCommand
 3036               	.LVL324:
 3037               	.LBE525:
 3038               	.LBE524:
 293:main.c        **** 
 3039               		.loc 1 293 0
 3040 0340 80E0      		ldi r24,lo8(.LC16)
 3041 0342 90E0      		ldi r25,hi8(.LC16)
 3042 0344 0E94 0000 		call LCD_Print
 3043               	.LVL325:
 3044               	.LBB526:
 3045               	.LBB527:
 883:main.c        **** }
 3046               		.loc 1 883 0
 3047 0348 80EC      		ldi r24,lo8(-64)
 3048 034a 0E94 0000 		call LCD_SendCommand
 3049               	.LVL326:
 3050               	.LBE527:
 3051               	.LBE526:
 296:main.c        **** 
 3052               		.loc 1 296 0
 3053 034e 80E0      		ldi r24,lo8(.LC17)
 3054 0350 90E0      		ldi r25,hi8(.LC17)
 3055 0352 0E94 0000 		call LCD_Print
 3056               	.LVL327:
 3057               	.L138:
 299:main.c        ****                             //LCD_Clear();  // Clear the screen for the next message
 3058               		.loc 1 299 0
 3059 0356 62E4      		ldi r22,lo8(66)
 3060 0358 81E0      		ldi r24,lo8(1)
 3061 035a 0E94 0000 		call isButtonPressed
 3062               	.LVL328:
 3063 035e 8823      		tst r24
 3064 0360 01F4      		brne .+2
 3065 0362 00C0      		rjmp .L142
 3066               	.LVL329:
 3067               	.L133:
 349:main.c        ****             uint8_t userCountValue = eeprom_read_byte(&userCount); // Get the user count from EEPRO
 3068               		.loc 1 349 0
 3069 0364 62E4      		ldi r22,lo8(66)
 3070 0366 81E0      		ldi r24,lo8(1)
 3071 0368 0E94 0000 		call isButtonPressed
 3072               	.LVL330:
 3073 036c 8823      		tst r24
 3074 036e 01F4      		brne .+2
 3075 0370 00C0      		rjmp .L144
 3076               	.LBB528:
 350:main.c        ****             if (userCountValue == 0) {
 3077               		.loc 1 350 0
 3078 0372 80E0      		ldi r24,lo8(userCount)
 3079 0374 90E0      		ldi r25,hi8(userCount)
 3080 0376 0E94 0000 		call eeprom_read_byte
 3081               	.LVL331:
 351:main.c        ****                 // No users registered, display a message and prevent voting
 3082               		.loc 1 351 0
 3083 037a 8111      		cpse r24,__zero_reg__
 3084 037c 00C0      		rjmp .L145
 353:main.c        ****                 LCD_Clear();
 3085               		.loc 1 353 0
 3086 037e 85E0      		ldi r24,lo8(5)
 3087               	.LVL332:
 3088 0380 0E94 0000 		call blinkLED_Buzzer
 3089               	.LVL333:
 354:main.c        ****                 LCD_SetPosition(0, 0);
 3090               		.loc 1 354 0
 3091 0384 0E94 0000 		call LCD_Clear
 3092               	.LVL334:
 3093               	.LBB529:
 3094               	.LBB530:
 883:main.c        **** }
 3095               		.loc 1 883 0
 3096 0388 80E8      		ldi r24,lo8(-128)
 3097 038a 0E94 0000 		call LCD_SendCommand
 3098               	.LVL335:
 3099               	.LBE530:
 3100               	.LBE529:
 356:main.c        ****                 LCD_SetPosition(1, 0);
 3101               		.loc 1 356 0
 3102 038e 80E0      		ldi r24,lo8(.LC22)
 3103 0390 90E0      		ldi r25,hi8(.LC22)
 3104 0392 0E94 0000 		call LCD_Print
 3105               	.LVL336:
 3106               	.LBB531:
 3107               	.LBB532:
 883:main.c        **** }
 3108               		.loc 1 883 0
 3109 0396 80EC      		ldi r24,lo8(-64)
 3110 0398 0E94 0000 		call LCD_SendCommand
 3111               	.LVL337:
 3112               	.LBE532:
 3113               	.LBE531:
 358:main.c        ****                 _delay_ms(100);  // Show the message for 0.1 seconds
 3114               		.loc 1 358 0
 3115 039c 80E0      		ldi r24,lo8(.LC23)
 3116 039e 90E0      		ldi r25,hi8(.LC23)
 3117 03a0 0E94 0000 		call LCD_Print
 3118               	.LVL338:
 3119               	.LBB533:
 3120               	.LBB534:
 187:/usr/lib/avr/include/util/delay.h **** 
 3121               		.loc 2 187 0
 3122 03a4 3FEF      		ldi r19,lo8(319999)
 3123 03a6 81EE      		ldi r24,hi8(319999)
 3124 03a8 94E0      		ldi r25,hlo8(319999)
 3125 03aa 3150      	1:	subi r19,1
 3126 03ac 8040      		sbci r24,0
 3127 03ae 9040      		sbci r25,0
 3128 03b0 01F4      		brne 1b
 3129               	.LVL339:
 3130               	.L192:
 3131               	.LBE534:
 3132               	.LBE533:
 3133               	.LBE528:
 3134               	.LBB605:
 3135               	.LBB606:
 3136 03b2 00C0      		rjmp .
 3137 03b4 0000      		nop
 3138 03b6 00C0      		rjmp .L119
 3139               	.LVL340:
 3140               	.L122:
 3141               	.LBE606:
 3142               	.LBE605:
 3143               	.LBB608:
 178:main.c        ****                         LCD_SetPosition(0, 0);
 3144               		.loc 1 178 0
 3145 03b8 0E94 0000 		call LCD_Clear
 3146               	.LVL341:
 3147               	.LBB508:
 3148               	.LBB509:
 883:main.c        **** }
 3149               		.loc 1 883 0
 3150 03bc 80E8      		ldi r24,lo8(-128)
 3151 03be 0E94 0000 		call LCD_SendCommand
 3152               	.LVL342:
 3153               	.LBE509:
 3154               	.LBE508:
 180:main.c        ****                         blinkLED_Buzzer(LED_PIN_RR);
 3155               		.loc 1 180 0
 3156 03c2 80E0      		ldi r24,lo8(.LC8)
 3157 03c4 90E0      		ldi r25,hi8(.LC8)
 3158 03c6 0E94 0000 		call LCD_Print
 3159               	.LVL343:
 3160               	.LBB510:
 3161               	.LBB511:
 3162 03ca 0E94 0000 		call blinkLED_Buzzer.part.2
 3163               	.LVL344:
 3164               	.LBE511:
 3165               	.LBE510:
 3166               	.LBB512:
 3167               	.LBB507:
 187:/usr/lib/avr/include/util/delay.h **** 
 3168               		.loc 2 187 0
 3169 03ce 9FEF      		ldi r25,lo8(159999)
 3170 03d0 E0E7      		ldi r30,hi8(159999)
 3171 03d2 F2E0      		ldi r31,hlo8(159999)
 3172 03d4 9150      	1:	subi r25,1
 3173 03d6 E040      		sbci r30,0
 3174 03d8 F040      		sbci r31,0
 3175 03da 01F4      		brne 1b
 3176 03dc 00C0      		rjmp .L193
 3177               	.LVL345:
 3178               	.L121:
 3179               	.LBE507:
 3180               	.LBE512:
 3181               	.LBB513:
 3182               	.LBB514:
 3183 03de 8FE3      		ldi r24,lo8(-25537)
 3184 03e0 9CE9      		ldi r25,hi8(-25537)
 3185 03e2 0197      	1:	sbiw r24,1
 3186 03e4 01F4      		brne 1b
 3187 03e6 00C0      		rjmp .
 3188 03e8 0000      		nop
 3189               	.LVL346:
 3190 03ea 91E0      		ldi r25,1
 3191 03ec 891A      		sub r8,r25
 3192 03ee 9108      		sbc r9,__zero_reg__
 3193               	.LVL347:
 3194               	.LBE514:
 3195               	.LBE513:
 152:main.c        ****                 // Actively scan for RFID card
 3196               		.loc 1 152 0
 3197 03f0 01F0      		breq .+2
 3198 03f2 00C0      		rjmp .L124
 3199 03f4 00C0      		rjmp .L123
 3200               	.LVL348:
 3201               	.L128:
 3202               	.LBE608:
 3203               	.LBB609:
 3204               	.LBB473:
 3205               	.LBB464:
 3206               	.LBB465:
 187:/usr/lib/avr/include/util/delay.h **** 
 3207               		.loc 2 187 0
 3208 03f6 8FE3      		ldi r24,lo8(-25537)
 3209 03f8 9CE9      		ldi r25,hi8(-25537)
 3210 03fa 0197      	1:	sbiw r24,1
 3211 03fc 01F4      		brne 1b
 3212 03fe 00C0      		rjmp .
 3213 0400 0000      		nop
 3214               	.LVL349:
 3215 0402 91E0      		ldi r25,1
 3216 0404 891A      		sub r8,r25
 3217 0406 9108      		sbc r9,__zero_reg__
 3218               	.LVL350:
 3219               	.LBE465:
 3220               	.LBE464:
 207:main.c        ****                     status = MFRC522_request(0x26, serial);  // Request RFID card scan
 3221               		.loc 1 207 0
 3222 0408 01F0      		breq .+2
 3223 040a 00C0      		rjmp .L131
 254:main.c        ****                     LCD_SetPosition(0, 0);
 3224               		.loc 1 254 0
 3225 040c 0E94 0000 		call LCD_Clear
 3226               	.LVL351:
 3227               	.LBB466:
 3228               	.LBB467:
 883:main.c        **** }
 3229               		.loc 1 883 0
 3230 0410 80E8      		ldi r24,lo8(-128)
 3231 0412 0E94 0000 		call LCD_SendCommand
 3232               	.LVL352:
 3233               	.LBE467:
 3234               	.LBE466:
 256:main.c        ****                     blinkLED_Buzzer(LED_PIN_RR);
 3235               		.loc 1 256 0
 3236 0416 80E0      		ldi r24,lo8(.LC8)
 3237 0418 90E0      		ldi r25,hi8(.LC8)
 3238 041a 0E94 0000 		call LCD_Print
 3239               	.LVL353:
 3240               	.LBB468:
 3241               	.LBB469:
 3242 041e 0E94 0000 		call blinkLED_Buzzer.part.2
 3243               	.LVL354:
 3244               	.LBE469:
 3245               	.LBE468:
 3246               	.LBB470:
 3247               	.LBB471:
 187:/usr/lib/avr/include/util/delay.h **** 
 3248               		.loc 2 187 0
 3249 0422 9FEF      		ldi r25,lo8(159999)
 3250 0424 E0E7      		ldi r30,hi8(159999)
 3251 0426 F2E0      		ldi r31,hlo8(159999)
 3252 0428 9150      	1:	subi r25,1
 3253 042a E040      		sbci r30,0
 3254 042c F040      		sbci r31,0
 3255 042e 01F4      		brne 1b
 3256 0430 00C0      		rjmp .L194
 3257               	.LVL355:
 3258               	.L127:
 3259               	.LBE471:
 3260               	.LBE470:
 3261               	.LBE473:
 262:main.c        ****                 LCD_SetPosition(0, 0);
 3262               		.loc 1 262 0
 3263 0432 0E94 0000 		call LCD_Clear
 3264               	.LVL356:
 3265               	.LBB474:
 3266               	.LBB475:
 883:main.c        **** }
 3267               		.loc 1 883 0
 3268 0436 80E8      		ldi r24,lo8(-128)
 3269 0438 0E94 0000 		call LCD_SendCommand
 3270               	.LVL357:
 3271               	.LBE475:
 3272               	.LBE474:
 264:main.c        ****                 LCD_SetPosition(1, 0);
 3273               		.loc 1 264 0
 3274 043c 80E0      		ldi r24,lo8(.LC13)
 3275 043e 90E0      		ldi r25,hi8(.LC13)
 3276 0440 0E94 0000 		call LCD_Print
 3277               	.LVL358:
 3278               	.LBB476:
 3279               	.LBB477:
 883:main.c        **** }
 3280               		.loc 1 883 0
 3281 0444 80EC      		ldi r24,lo8(-64)
 3282 0446 0E94 0000 		call LCD_SendCommand
 3283               	.LVL359:
 3284               	.LBE477:
 3285               	.LBE476:
 266:main.c        ****                 blinkLED_Buzzer(LED_PIN_RR);
 3286               		.loc 1 266 0
 3287 044a 80E0      		ldi r24,lo8(.LC14)
 3288 044c 90E0      		ldi r25,hi8(.LC14)
 3289 044e 0E94 0000 		call LCD_Print
 3290               	.LVL360:
 3291               	.LBB478:
 3292               	.LBB479:
 3293 0452 0E94 0000 		call blinkLED_Buzzer.part.2
 3294               	.LVL361:
 3295               	.LBE479:
 3296               	.LBE478:
 3297               	.LBB480:
 3298               	.LBB481:
 187:/usr/lib/avr/include/util/delay.h **** 
 3299               		.loc 2 187 0
 3300 0456 EFEF      		ldi r30,lo8(319999)
 3301 0458 F1EE      		ldi r31,hi8(319999)
 3302 045a 24E0      		ldi r18,hlo8(319999)
 3303 045c E150      	1:	subi r30,1
 3304 045e F040      		sbci r31,0
 3305 0460 2040      		sbci r18,0
 3306 0462 01F4      		brne 1b
 3307               	.LVL362:
 3308               	.L194:
 3309 0464 00C0      		rjmp .
 3310 0466 0000      		nop
 3311 0468 00C0      		rjmp .L126
 3312               	.LVL363:
 3313               	.L142:
 3314               	.LBE481:
 3315               	.LBE480:
 3316               	.LBE609:
 3317               	.LBB610:
 3318               	.LBB611:
 883:main.c        **** }
 3319               		.loc 1 883 0
 3320 046a 80E8      		ldi r24,lo8(-128)
 3321 046c 0E94 0000 		call LCD_SendCommand
 3322               	.LVL364:
 3323               	.LBE611:
 3324               	.LBE610:
 302:main.c        ****                             LCD_SetPosition(1, 0);
 3325               		.loc 1 302 0
 3326 0470 80E0      		ldi r24,lo8(.LC16)
 3327 0472 90E0      		ldi r25,hi8(.LC16)
 3328 0474 0E94 0000 		call LCD_Print
 3329               	.LVL365:
 3330               	.LBB612:
 3331               	.LBB613:
 883:main.c        **** }
 3332               		.loc 1 883 0
 3333 0478 80EC      		ldi r24,lo8(-64)
 3334 047a 0E94 0000 		call LCD_SendCommand
 3335               	.LVL366:
 3336               	.LBE613:
 3337               	.LBE612:
 304:main.c        ****                             
 3338               		.loc 1 304 0
 3339 047e 80E0      		ldi r24,lo8(.LC17)
 3340 0480 90E0      		ldi r25,hi8(.LC17)
 3341 0482 0E94 0000 		call LCD_Print
 3342               	.LVL367:
 306:main.c        ****                             if (status == MI_OK && MFRC522_anticoll(serial) == MI_OK) {
 3343               		.loc 1 306 0
 3344 0486 BE01      		movw r22,r28
 3345 0488 6F5B      		subi r22,-65
 3346 048a 7F4F      		sbci r23,-1
 3347 048c 86E2      		ldi r24,lo8(38)
 3348 048e 0E94 0000 		call MFRC522_request
 3349               	.LVL368:
 307:main.c        ****                                 if (!isRegistered(serial)) {
 3350               		.loc 1 307 0
 3351 0492 8111      		cpse r24,__zero_reg__
 3352 0494 00C0      		rjmp .L138
 307:main.c        ****                                 if (!isRegistered(serial)) {
 3353               		.loc 1 307 0 is_stmt 0 discriminator 1
 3354 0496 CE01      		movw r24,r28
 3355               	.LVL369:
 3356 0498 8F5B      		subi r24,-65
 3357 049a 9F4F      		sbci r25,-1
 3358 049c 0E94 0000 		call MFRC522_anticoll
 3359               	.LVL370:
 3360 04a0 8111      		cpse r24,__zero_reg__
 3361 04a2 00C0      		rjmp .L138
 308:main.c        ****                                     storeCard(serial);
 3362               		.loc 1 308 0 is_stmt 1
 3363 04a4 CE01      		movw r24,r28
 3364 04a6 8F5B      		subi r24,-65
 3365 04a8 9F4F      		sbci r25,-1
 3366 04aa 0E94 0000 		call isRegistered
 3367               	.LVL371:
 3368 04ae 8111      		cpse r24,__zero_reg__
 3369 04b0 00C0      		rjmp .L140
 309:main.c        ****                                     LCD_Clear();  // Clear the screen after successful registration
 3370               		.loc 1 309 0
 3371 04b2 CE01      		movw r24,r28
 3372 04b4 8F5B      		subi r24,-65
 3373 04b6 9F4F      		sbci r25,-1
 3374 04b8 0E94 0000 		call storeCard
 3375               	.LVL372:
 310:main.c        ****                                     LCD_SetPosition(0, 0);
 3376               		.loc 1 310 0
 3377 04bc 0E94 0000 		call LCD_Clear
 3378               	.LVL373:
 3379               	.LBB614:
 3380               	.LBB615:
 883:main.c        **** }
 3381               		.loc 1 883 0
 3382 04c0 80E8      		ldi r24,lo8(-128)
 3383 04c2 0E94 0000 		call LCD_SendCommand
 3384               	.LVL374:
 3385               	.LBE615:
 3386               	.LBE614:
 312:main.c        ****                                     LCD_SetPosition(1, 0);
 3387               		.loc 1 312 0
 3388 04c6 80E0      		ldi r24,lo8(.LC16)
 3389 04c8 90E0      		ldi r25,hi8(.LC16)
 3390 04ca 0E94 0000 		call LCD_Print
 3391               	.LVL375:
 3392               	.LBB616:
 3393               	.LBB617:
 883:main.c        **** }
 3394               		.loc 1 883 0
 3395 04ce 80EC      		ldi r24,lo8(-64)
 3396 04d0 0E94 0000 		call LCD_SendCommand
 3397               	.LVL376:
 3398               	.LBE617:
 3399               	.LBE616:
 314:main.c        ****                                     blinkLED_Buzzer(LED_PIN_Reg);
 3400               		.loc 1 314 0
 3401 04d4 80E0      		ldi r24,lo8(.LC18)
 3402 04d6 90E0      		ldi r25,hi8(.LC18)
 3403 04d8 0E94 0000 		call LCD_Print
 3404               	.LVL377:
 315:main.c        ****                                     _delay_ms(100);
 3405               		.loc 1 315 0
 3406 04dc 83E0      		ldi r24,lo8(3)
 3407 04de 0E94 0000 		call blinkLED_Buzzer
 3408               	.LVL378:
 3409               	.LBB618:
 3410               	.LBB619:
 187:/usr/lib/avr/include/util/delay.h **** 
 3411               		.loc 2 187 0
 3412 04e2 EFEF      		ldi r30,lo8(319999)
 3413 04e4 F1EE      		ldi r31,hi8(319999)
 3414 04e6 24E0      		ldi r18,hlo8(319999)
 3415 04e8 E150      	1:	subi r30,1
 3416 04ea F040      		sbci r31,0
 3417 04ec 2040      		sbci r18,0
 3418 04ee 01F4      		brne 1b
 3419               	.LVL379:
 3420               	.L196:
 3421               	.LBE619:
 3422               	.LBE618:
 3423               	.LBB620:
 3424               	.LBB621:
 3425 04f0 00C0      		rjmp .
 3426 04f2 0000      		nop
 3427 04f4 00C0      		rjmp .L138
 3428               	.L140:
 3429               	.LBE621:
 3430               	.LBE620:
 319:main.c        ****                                     LCD_SetPosition(0, 0);
 3431               		.loc 1 319 0
 3432 04f6 0E94 0000 		call LCD_Clear
 3433               	.LVL380:
 3434               	.LBB623:
 3435               	.LBB624:
 883:main.c        **** }
 3436               		.loc 1 883 0
 3437 04fa 80E8      		ldi r24,lo8(-128)
 3438 04fc 0E94 0000 		call LCD_SendCommand
 3439               	.LVL381:
 3440               	.LBE624:
 3441               	.LBE623:
 321:main.c        ****                                     LCD_SetPosition(1, 0);
 3442               		.loc 1 321 0
 3443 0500 80E0      		ldi r24,lo8(.LC19)
 3444 0502 90E0      		ldi r25,hi8(.LC19)
 3445 0504 0E94 0000 		call LCD_Print
 3446               	.LVL382:
 3447               	.LBB625:
 3448               	.LBB626:
 883:main.c        **** }
 3449               		.loc 1 883 0
 3450 0508 80EC      		ldi r24,lo8(-64)
 3451 050a 0E94 0000 		call LCD_SendCommand
 3452               	.LVL383:
 3453               	.LBE626:
 3454               	.LBE625:
 323:main.c        ****                                     blinkLED_Buzzer(LED_PIN_Reg);
 3455               		.loc 1 323 0
 3456 050e 80E0      		ldi r24,lo8(.LC20)
 3457 0510 90E0      		ldi r25,hi8(.LC20)
 3458 0512 0E94 0000 		call LCD_Print
 3459               	.LVL384:
 324:main.c        ****                                     _delay_ms(100);
 3460               		.loc 1 324 0
 3461 0516 83E0      		ldi r24,lo8(3)
 3462 0518 0E94 0000 		call blinkLED_Buzzer
 3463               	.LVL385:
 3464               	.LBB627:
 3465               	.LBB622:
 187:/usr/lib/avr/include/util/delay.h **** 
 3466               		.loc 2 187 0
 3467 051c 3FEF      		ldi r19,lo8(319999)
 3468 051e 81EE      		ldi r24,hi8(319999)
 3469 0520 94E0      		ldi r25,hlo8(319999)
 3470 0522 3150      	1:	subi r19,1
 3471 0524 8040      		sbci r24,0
 3472 0526 9040      		sbci r25,0
 3473 0528 01F4      		brne 1b
 3474 052a 00C0      		rjmp .L196
 3475               	.LVL386:
 3476               	.L136:
 3477               	.LBE622:
 3478               	.LBE627:
 333:main.c        ****                         LCD_SetPosition(0, 0);
 3479               		.loc 1 333 0
 3480 052c 0E94 0000 		call LCD_Clear
 3481               	.LVL387:
 3482               	.LBB628:
 3483               	.LBB629:
 883:main.c        **** }
 3484               		.loc 1 883 0
 3485 0530 80E8      		ldi r24,lo8(-128)
 3486 0532 0E94 0000 		call LCD_SendCommand
 3487               	.LVL388:
 3488               	.LBE629:
 3489               	.LBE628:
 335:main.c        ****                         LCD_SetPosition(1, 0);
 3490               		.loc 1 335 0
 3491 0536 80E0      		ldi r24,lo8(.LC8)
 3492 0538 90E0      		ldi r25,hi8(.LC8)
 3493 053a 0E94 0000 		call LCD_Print
 3494               	.LVL389:
 3495               	.LBB630:
 3496               	.LBB631:
 883:main.c        **** }
 3497               		.loc 1 883 0
 3498 053e 80EC      		ldi r24,lo8(-64)
 3499 0540 0E94 0000 		call LCD_SendCommand
 3500               	.LVL390:
 3501               	.LBE631:
 3502               	.LBE630:
 337:main.c        ****                         blinkLED_Buzzer(LED_PIN_RR);
 3503               		.loc 1 337 0
 3504 0544 80E0      		ldi r24,lo8(.LC21)
 3505 0546 90E0      		ldi r25,hi8(.LC21)
 3506 0548 0E94 0000 		call LCD_Print
 3507               	.LVL391:
 3508               	.LBB632:
 3509               	.LBB633:
 3510 054c 0E94 0000 		call blinkLED_Buzzer.part.2
 3511               	.LVL392:
 3512               	.LBE633:
 3513               	.LBE632:
 3514               	.LBB634:
 3515               	.LBB635:
 187:/usr/lib/avr/include/util/delay.h **** 
 3516               		.loc 2 187 0
 3517 0550 EFEF      		ldi r30,lo8(319999)
 3518 0552 F1EE      		ldi r31,hi8(319999)
 3519 0554 24E0      		ldi r18,hlo8(319999)
 3520 0556 E150      	1:	subi r30,1
 3521 0558 F040      		sbci r31,0
 3522 055a 2040      		sbci r18,0
 3523 055c 01F4      		brne 1b
 3524 055e 00C0      		rjmp .
 3525 0560 0000      		nop
 3526               	.LVL393:
 3527 0562 00C0      		rjmp .L195
 3528               	.LVL394:
 3529               	.L145:
 3530               	.LBE635:
 3531               	.LBE634:
 3532               	.LBB636:
 3533               	.LBB535:
 3534               	.LBB536:
 3535 0564 0E94 0000 		call blinkLED_Buzzer.part.2
 3536               	.LVL395:
 3537               	.L197:
 3538               	.LBE536:
 3539               	.LBE535:
 363:main.c        **** 
 3540               		.loc 1 363 0
 3541 0568 0E94 0000 		call LCD_Clear
 3542               	.LVL396:
 3543               	.LBB537:
 3544               	.LBB538:
 883:main.c        **** }
 3545               		.loc 1 883 0
 3546 056c 80E8      		ldi r24,lo8(-128)
 3547 056e 0E94 0000 		call LCD_SendCommand
 3548               	.LVL397:
 3549               	.LBE538:
 3550               	.LBE537:
 367:main.c        **** 
 3551               		.loc 1 367 0
 3552 0572 80E0      		ldi r24,lo8(.LC3)
 3553 0574 90E0      		ldi r25,hi8(.LC3)
 3554 0576 0E94 0000 		call LCD_Print
 3555               	.LVL398:
 3556               	.L147:
 370:main.c        ****                 if (status == MI_OK && MFRC522_anticoll(serial) == MI_OK) {
 3557               		.loc 1 370 0
 3558 057a BE01      		movw r22,r28
 3559 057c 6F5B      		subi r22,-65
 3560 057e 7F4F      		sbci r23,-1
 3561 0580 86E2      		ldi r24,lo8(38)
 3562 0582 0E94 0000 		call MFRC522_request
 3563               	.LVL399:
 371:main.c        ****                     if (checkAdmin(serial)) {
 3564               		.loc 1 371 0
 3565 0586 8111      		cpse r24,__zero_reg__
 3566 0588 00C0      		rjmp .L147
 371:main.c        ****                     if (checkAdmin(serial)) {
 3567               		.loc 1 371 0 is_stmt 0 discriminator 1
 3568 058a CE01      		movw r24,r28
 3569               	.LVL400:
 3570 058c 8F5B      		subi r24,-65
 3571 058e 9F4F      		sbci r25,-1
 3572 0590 0E94 0000 		call MFRC522_anticoll
 3573               	.LVL401:
 3574 0594 8111      		cpse r24,__zero_reg__
 3575 0596 00C0      		rjmp .L147
 372:main.c        ****                         blinkLED_Buzzer(LED_PIN_RR);
 3576               		.loc 1 372 0 is_stmt 1
 3577 0598 CE01      		movw r24,r28
 3578 059a 8F5B      		subi r24,-65
 3579 059c 9F4F      		sbci r25,-1
 3580 059e 0E94 0000 		call checkAdmin
 3581               	.LVL402:
 3582 05a2 8823      		tst r24
 3583 05a4 01F4      		brne .+2
 3584 05a6 00C0      		rjmp .L149
 3585               	.LVL403:
 3586               	.LBB539:
 3587               	.LBB540:
 3588 05a8 0E94 0000 		call blinkLED_Buzzer.part.2
 3589               	.LVL404:
 3590               	.LBE540:
 3591               	.LBE539:
 374:main.c        ****                         LCD_SetPosition(0, 0);
 3592               		.loc 1 374 0
 3593 05ac 0E94 0000 		call LCD_Clear
 3594               	.LVL405:
 3595               	.LBB541:
 3596               	.LBB542:
 883:main.c        **** }
 3597               		.loc 1 883 0
 3598 05b0 80E8      		ldi r24,lo8(-128)
 3599 05b2 0E94 0000 		call LCD_SendCommand
 3600               	.LVL406:
 3601               	.LBE542:
 3602               	.LBE541:
 376:main.c        ****                         _delay_ms(100);  // Give some time to show verification message
 3603               		.loc 1 376 0
 3604 05b6 80E0      		ldi r24,lo8(.LC4)
 3605 05b8 90E0      		ldi r25,hi8(.LC4)
 3606 05ba 0E94 0000 		call LCD_Print
 3607               	.LVL407:
 3608               	.LBB543:
 3609               	.LBB544:
 187:/usr/lib/avr/include/util/delay.h **** 
 3610               		.loc 2 187 0
 3611 05be EFEF      		ldi r30,lo8(319999)
 3612 05c0 F1EE      		ldi r31,hi8(319999)
 3613 05c2 24E0      		ldi r18,hlo8(319999)
 3614 05c4 E150      	1:	subi r30,1
 3615 05c6 F040      		sbci r31,0
 3616 05c8 2040      		sbci r18,0
 3617 05ca 01F4      		brne 1b
 3618               	.L200:
 3619               	.LBE544:
 3620               	.LBE543:
 3621               	.LBB545:
 3622               	.LBB546:
 3623               	.LBB547:
 3624 05cc 00C0      		rjmp .
 3625 05ce 0000      		nop
 3626               	.L165:
 3627               	.LBE547:
 3628               	.LBE546:
 570:main.c        ****                         LCD_SetPosition(0, 0);
 3629               		.loc 1 570 0
 3630 05d0 0E94 0000 		call LCD_Clear
 3631               	.LVL408:
 3632               	.LBB549:
 3633               	.LBB550:
 883:main.c        **** }
 3634               		.loc 1 883 0
 3635 05d4 80E8      		ldi r24,lo8(-128)
 3636 05d6 0E94 0000 		call LCD_SendCommand
 3637               	.LVL409:
 3638               	.LBE550:
 3639               	.LBE549:
 572:main.c        ****                         LCD_SetPosition(1, 0);
 3640               		.loc 1 572 0
 3641 05da 80E0      		ldi r24,lo8(.LC17)
 3642 05dc 90E0      		ldi r25,hi8(.LC17)
 3643 05de 0E94 0000 		call LCD_Print
 3644               	.LVL410:
 3645               	.LBB551:
 3646               	.LBB552:
 883:main.c        **** }
 3647               		.loc 1 883 0
 3648 05e2 80EC      		ldi r24,lo8(-64)
 3649 05e4 0E94 0000 		call LCD_SendCommand
 3650               	.LVL411:
 3651               	.LBE552:
 3652               	.LBE551:
 574:main.c        ****                     }
 3653               		.loc 1 574 0
 3654 05e8 80E0      		ldi r24,lo8(.LC24)
 3655 05ea 90E0      		ldi r25,hi8(.LC24)
 3656 05ec 0E94 0000 		call LCD_Print
 3657               	.LVL412:
 3658               	.L161:
 3659               	.LBE545:
 399:main.c        ****                 if (status == MI_OK && MFRC522_anticoll(serial) == MI_OK) {
 3660               		.loc 1 399 0
 3661 05f0 BE01      		movw r22,r28
 3662 05f2 6F5B      		subi r22,-65
 3663 05f4 7F4F      		sbci r23,-1
 3664 05f6 86E2      		ldi r24,lo8(38)
 3665 05f8 0E94 0000 		call MFRC522_request
 3666               	.LVL413:
 400:main.c        ****                     uint8_t userIndex = getUserIndex(serial);  // Find the user in registered IDs
 3667               		.loc 1 400 0
 3668 05fc 8111      		cpse r24,__zero_reg__
 3669 05fe 00C0      		rjmp .L153
 400:main.c        ****                     uint8_t userIndex = getUserIndex(serial);  // Find the user in registered IDs
 3670               		.loc 1 400 0 is_stmt 0 discriminator 1
 3671 0600 CE01      		movw r24,r28
 3672               	.LVL414:
 3673 0602 8F5B      		subi r24,-65
 3674 0604 9F4F      		sbci r25,-1
 3675 0606 0E94 0000 		call MFRC522_anticoll
 3676               	.LVL415:
 3677 060a 8111      		cpse r24,__zero_reg__
 3678 060c 00C0      		rjmp .L153
 3679               	.LBB578:
 401:main.c        ****                     if (userIndex != 255) {  // User is registered
 3680               		.loc 1 401 0 is_stmt 1
 3681 060e CE01      		movw r24,r28
 3682 0610 8F5B      		subi r24,-65
 3683 0612 9F4F      		sbci r25,-1
 3684 0614 0E94 0000 		call getUserIndex
 3685               	.LVL416:
 402:main.c        ****                         if (votedUsers[userIndex] == 0) {  // Check if the user has not voted
 3686               		.loc 1 402 0
 3687 0618 8F3F      		cpi r24,lo8(-1)
 3688 061a 01F4      		brne .+2
 3689 061c 00C0      		rjmp .L155
 403:main.c        ****                             LCD_Clear();
 3690               		.loc 1 403 0
 3691 061e 90E0      		ldi r25,0
 3692 0620 FC01      		movw r30,r24
 3693 0622 E050      		subi r30,lo8(-(votedUsers))
 3694 0624 F040      		sbci r31,hi8(-(votedUsers))
 3695 0626 4F01      		movw r8,r30
 3696 0628 8081      		ld r24,Z
 3697               	.LVL417:
 3698 062a 8111      		cpse r24,__zero_reg__
 3699 062c 00C0      		rjmp .L156
 404:main.c        ****                             LCD_SetPosition(0, 0);
 3700               		.loc 1 404 0
 3701 062e 0E94 0000 		call LCD_Clear
 3702               	.LVL418:
 3703               	.LBB579:
 3704               	.LBB580:
 883:main.c        **** }
 3705               		.loc 1 883 0
 3706 0632 80E8      		ldi r24,lo8(-128)
 3707 0634 0E94 0000 		call LCD_SendCommand
 3708               	.LVL419:
 3709               	.LBE580:
 3710               	.LBE579:
 406:main.c        ****                             blinkLED_Buzzer(LED_PIN_Reg);
 3711               		.loc 1 406 0
 3712 0638 80E0      		ldi r24,lo8(.LC25)
 3713 063a 90E0      		ldi r25,hi8(.LC25)
 3714 063c 0E94 0000 		call LCD_Print
 3715               	.LVL420:
 407:main.c        ****                             
 3716               		.loc 1 407 0
 3717 0640 83E0      		ldi r24,lo8(3)
 3718 0642 0E94 0000 		call blinkLED_Buzzer
 3719               	.LVL421:
 3720               	.L160:
 410:main.c        ****                                     voteA++;
 3721               		.loc 1 410 0
 3722 0646 63E4      		ldi r22,lo8(67)
 3723 0648 80E0      		ldi r24,0
 3724 064a 0E94 0000 		call isButtonPressed
 3725               	.LVL422:
 3726 064e 8823      		tst r24
 3727 0650 01F0      		breq .L157
 411:main.c        ****                                     blinkLED_Buzzer(LED_PIN_Vote);
 3728               		.loc 1 411 0
 3729 0652 8091 0000 		lds r24,voteA
 3730 0656 8F5F      		subi r24,lo8(-(1))
 3731 0658 8093 0000 		sts voteA,r24
 3732               	.L201:
 457:main.c        ****                                     LCD_Clear();
 3733               		.loc 1 457 0
 3734 065c 85E0      		ldi r24,lo8(5)
 3735 065e 0E94 0000 		call blinkLED_Buzzer
 3736               	.LVL423:
 458:main.c        ****                                     LCD_SetPosition(0, 0);
 3737               		.loc 1 458 0
 3738 0662 0E94 0000 		call LCD_Clear
 3739               	.LVL424:
 3740               	.LBB581:
 3741               	.LBB582:
 883:main.c        **** }
 3742               		.loc 1 883 0
 3743 0666 80E8      		ldi r24,lo8(-128)
 3744 0668 0E94 0000 		call LCD_SendCommand
 3745               	.LVL425:
 3746               	.LBE582:
 3747               	.LBE581:
 460:main.c        ****                                     votedUsers[userIndex] = 1;  // Mark the user as having voted
 3748               		.loc 1 460 0
 3749 066c 80E0      		ldi r24,lo8(.LC26)
 3750 066e 90E0      		ldi r25,hi8(.LC26)
 3751 0670 0E94 0000 		call LCD_Print
 3752               	.LVL426:
 461:main.c        ****                                     _delay_ms(100);
 3753               		.loc 1 461 0
 3754 0674 81E0      		ldi r24,lo8(1)
 3755 0676 F401      		movw r30,r8
 3756 0678 8083      		st Z,r24
 3757               	.LVL427:
 3758               	.L198:
 3759               	.LBB583:
 3760               	.LBB584:
 187:/usr/lib/avr/include/util/delay.h **** 
 3761               		.loc 2 187 0
 3762 067a FFEF      		ldi r31,lo8(319999)
 3763 067c 21EE      		ldi r18,hi8(319999)
 3764 067e 34E0      		ldi r19,hlo8(319999)
 3765 0680 F150      	1:	subi r31,1
 3766 0682 2040      		sbci r18,0
 3767 0684 3040      		sbci r19,0
 3768 0686 01F4      		brne 1b
 3769 0688 00C0      		rjmp .L199
 3770               	.LVL428:
 3771               	.L149:
 3772               	.LBE584:
 3773               	.LBE583:
 3774               	.LBE578:
 381:main.c        ****                         LCD_SetPosition(0, 0);
 3775               		.loc 1 381 0
 3776 068a 0E94 0000 		call LCD_Clear
 3777               	.LVL429:
 3778               	.LBB597:
 3779               	.LBB598:
 883:main.c        **** }
 3780               		.loc 1 883 0
 3781 068e 80E8      		ldi r24,lo8(-128)
 3782 0690 0E94 0000 		call LCD_SendCommand
 3783               	.LVL430:
 3784               	.LBE598:
 3785               	.LBE597:
 383:main.c        ****                         _delay_ms(100);
 3786               		.loc 1 383 0
 3787 0694 80E0      		ldi r24,lo8(.LC8)
 3788 0696 90E0      		ldi r25,hi8(.LC8)
 3789 0698 0E94 0000 		call LCD_Print
 3790               	.LVL431:
 3791               	.LBB599:
 3792               	.LBB600:
 187:/usr/lib/avr/include/util/delay.h **** 
 3793               		.loc 2 187 0
 3794 069c 3FEF      		ldi r19,lo8(319999)
 3795 069e 81EE      		ldi r24,hi8(319999)
 3796 06a0 94E0      		ldi r25,hlo8(319999)
 3797 06a2 3150      	1:	subi r19,1
 3798 06a4 8040      		sbci r24,0
 3799 06a6 9040      		sbci r25,0
 3800 06a8 01F4      		brne 1b
 3801 06aa 00C0      		rjmp .
 3802 06ac 0000      		nop
 3803               	.LVL432:
 3804 06ae 00C0      		rjmp .L197
 3805               	.LVL433:
 3806               	.L157:
 3807               	.LBE600:
 3808               	.LBE599:
 3809               	.LBB601:
 425:main.c        ****                                     voteB++;
 3810               		.loc 1 425 0
 3811 06b0 63E4      		ldi r22,lo8(67)
 3812 06b2 81E0      		ldi r24,lo8(1)
 3813 06b4 0E94 0000 		call isButtonPressed
 3814               	.LVL434:
 3815 06b8 8823      		tst r24
 3816 06ba 01F0      		breq .L158
 426:main.c        ****                                     blinkLED_Buzzer(LED_PIN_Vote);
 3817               		.loc 1 426 0
 3818 06bc 8091 0000 		lds r24,voteB
 3819 06c0 8F5F      		subi r24,lo8(-(1))
 3820 06c2 8093 0000 		sts voteB,r24
 3821 06c6 00C0      		rjmp .L201
 3822               	.L158:
 440:main.c        ****                                     voteC++;
 3823               		.loc 1 440 0
 3824 06c8 63E4      		ldi r22,lo8(67)
 3825 06ca 82E0      		ldi r24,lo8(2)
 3826 06cc 0E94 0000 		call isButtonPressed
 3827               	.LVL435:
 3828 06d0 8823      		tst r24
 3829 06d2 01F0      		breq .L159
 441:main.c        ****                                     blinkLED_Buzzer(LED_PIN_Vote);
 3830               		.loc 1 441 0
 3831 06d4 8091 0000 		lds r24,voteC
 3832 06d8 8F5F      		subi r24,lo8(-(1))
 3833 06da 8093 0000 		sts voteC,r24
 3834 06de 00C0      		rjmp .L201
 3835               	.L159:
 455:main.c        ****                                     voteD++;
 3836               		.loc 1 455 0
 3837 06e0 63E4      		ldi r22,lo8(67)
 3838 06e2 83E0      		ldi r24,lo8(3)
 3839 06e4 0E94 0000 		call isButtonPressed
 3840               	.LVL436:
 3841 06e8 8823      		tst r24
 3842 06ea 01F4      		brne .+2
 3843 06ec 00C0      		rjmp .L160
 456:main.c        ****                                     blinkLED_Buzzer(LED_PIN_Vote);
 3844               		.loc 1 456 0
 3845 06ee 8091 0000 		lds r24,voteD
 3846 06f2 8F5F      		subi r24,lo8(-(1))
 3847 06f4 8093 0000 		sts voteD,r24
 3848 06f8 00C0      		rjmp .L201
 3849               	.LVL437:
 3850               	.L156:
 472:main.c        ****                             LCD_SetPosition(0, 0);
 3851               		.loc 1 472 0
 3852 06fa 0E94 0000 		call LCD_Clear
 3853               	.LVL438:
 3854               	.LBB586:
 3855               	.LBB587:
 883:main.c        **** }
 3856               		.loc 1 883 0
 3857 06fe 80E8      		ldi r24,lo8(-128)
 3858 0700 0E94 0000 		call LCD_SendCommand
 3859               	.LVL439:
 3860               	.LBE587:
 3861               	.LBE586:
 474:main.c        ****                             blinkLED_Buzzer(LED_PIN_Reg);
 3862               		.loc 1 474 0
 3863 0704 80E0      		ldi r24,lo8(.LC27)
 3864 0706 90E0      		ldi r25,hi8(.LC27)
 3865 0708 0E94 0000 		call LCD_Print
 3866               	.LVL440:
 475:main.c        ****                             _delay_ms(100);
 3867               		.loc 1 475 0
 3868 070c 83E0      		ldi r24,lo8(3)
 3869 070e 0E94 0000 		call blinkLED_Buzzer
 3870               	.LVL441:
 3871               	.LBB588:
 3872               	.LBB589:
 187:/usr/lib/avr/include/util/delay.h **** 
 3873               		.loc 2 187 0
 3874 0712 8FEF      		ldi r24,lo8(319999)
 3875 0714 91EE      		ldi r25,hi8(319999)
 3876 0716 E4E0      		ldi r30,hlo8(319999)
 3877 0718 8150      	1:	subi r24,1
 3878 071a 9040      		sbci r25,0
 3879 071c E040      		sbci r30,0
 3880 071e 01F4      		brne 1b
 3881               	.LVL442:
 3882               	.L199:
 3883               	.LBE589:
 3884               	.LBE588:
 3885               	.LBB590:
 3886               	.LBB585:
 3887 0720 00C0      		rjmp .
 3888 0722 0000      		nop
 3889               	.LBE585:
 3890               	.LBE590:
 491:main.c        ****                         LCD_SetPosition(0, 0);
 3891               		.loc 1 491 0
 3892 0724 0E94 0000 		call LCD_Clear
 3893               	.LVL443:
 3894               	.LBB591:
 3895               	.LBB592:
 883:main.c        **** }
 3896               		.loc 1 883 0
 3897 0728 80E8      		ldi r24,lo8(-128)
 3898 072a 0E94 0000 		call LCD_SendCommand
 3899               	.LVL444:
 3900               	.LBE592:
 3901               	.LBE591:
 493:main.c        ****                         LCD_SetPosition(1, 0);
 3902               		.loc 1 493 0
 3903 072e 80E0      		ldi r24,lo8(.LC17)
 3904 0730 90E0      		ldi r25,hi8(.LC17)
 3905 0732 0E94 0000 		call LCD_Print
 3906               	.LVL445:
 3907               	.LBB593:
 3908               	.LBB594:
 883:main.c        **** }
 3909               		.loc 1 883 0
 3910 0736 80EC      		ldi r24,lo8(-64)
 3911 0738 0E94 0000 		call LCD_SendCommand
 3912               	.LVL446:
 3913               	.LBE594:
 3914               	.LBE593:
 495:main.c        ****                     }
 3915               		.loc 1 495 0
 3916 073c 80E0      		ldi r24,lo8(.LC24)
 3917 073e 90E0      		ldi r25,hi8(.LC24)
 3918 0740 0E94 0000 		call LCD_Print
 3919               	.LVL447:
 3920               	.L153:
 3921               	.LBE601:
 500:main.c        ****                     LCD_Clear();
 3922               		.loc 1 500 0
 3923 0744 62E4      		ldi r22,lo8(66)
 3924 0746 86E0      		ldi r24,lo8(6)
 3925 0748 0E94 0000 		call isButtonPressed
 3926               	.LVL448:
 3927 074c 8823      		tst r24
 3928 074e 01F4      		brne .+2
 3929 0750 00C0      		rjmp .L161
 3930               	.LBB602:
 501:main.c        ****                     LCD_SetPosition(0, 0);
 3931               		.loc 1 501 0
 3932 0752 0E94 0000 		call LCD_Clear
 3933               	.LVL449:
 3934               	.LBB553:
 3935               	.LBB554:
 883:main.c        **** }
 3936               		.loc 1 883 0
 3937 0756 80E8      		ldi r24,lo8(-128)
 3938 0758 0E94 0000 		call LCD_SendCommand
 3939               	.LVL450:
 3940               	.LBE554:
 3941               	.LBE553:
 503:main.c        **** 
 3942               		.loc 1 503 0
 3943 075c 80E0      		ldi r24,lo8(.LC3)
 3944 075e 90E0      		ldi r25,hi8(.LC3)
 3945 0760 0E94 0000 		call LCD_Print
 3946               	.LVL451:
 3947 0764 92E3      		ldi r25,lo8(50)
 3948 0766 892E      		mov r8,r25
 3949 0768 912C      		mov r9,__zero_reg__
 3950               	.LVL452:
 3951               	.L166:
 510:main.c        ****                         if (status == MI_OK && MFRC522_anticoll(serial) == MI_OK) {
 3952               		.loc 1 510 0
 3953 076a BE01      		movw r22,r28
 3954 076c 6F5B      		subi r22,-65
 3955 076e 7F4F      		sbci r23,-1
 3956 0770 86E2      		ldi r24,lo8(38)
 3957 0772 0E94 0000 		call MFRC522_request
 3958               	.LVL453:
 511:main.c        ****                             if (checkAdmin(serial)) {
 3959               		.loc 1 511 0
 3960 0776 8111      		cpse r24,__zero_reg__
 3961 0778 00C0      		rjmp .L162
 511:main.c        ****                             if (checkAdmin(serial)) {
 3962               		.loc 1 511 0 is_stmt 0 discriminator 1
 3963 077a CE01      		movw r24,r28
 3964               	.LVL454:
 3965 077c 8F5B      		subi r24,-65
 3966 077e 9F4F      		sbci r25,-1
 3967 0780 0E94 0000 		call MFRC522_anticoll
 3968               	.LVL455:
 3969 0784 8111      		cpse r24,__zero_reg__
 3970 0786 00C0      		rjmp .L162
 512:main.c        ****                                 adminVerified = 1;
 3971               		.loc 1 512 0 is_stmt 1
 3972 0788 CE01      		movw r24,r28
 3973 078a 8F5B      		subi r24,-65
 3974 078c 9F4F      		sbci r25,-1
 3975 078e 0E94 0000 		call checkAdmin
 3976               	.LVL456:
 3977 0792 8823      		tst r24
 3978 0794 01F4      		brne .+2
 3979 0796 00C0      		rjmp .L163
 3980               	.LVL457:
 3981               	.LBB555:
 3982               	.LBB556:
 3983               	.LBB557:
 3984 0798 0E94 0000 		call blinkLED_Buzzer.part.2
 3985               	.LVL458:
 3986               	.LBE557:
 3987               	.LBE556:
 516:main.c        ****                                 uint8_t userNum = eeprom_read_byte(&userCount);
 3988               		.loc 1 516 0
 3989 079c 8091 0000 		lds r24,voteA
 3990 07a0 9091 0000 		lds r25,voteB
 3991 07a4 890F      		add r24,r25
 3992 07a6 9091 0000 		lds r25,voteC
 3993 07aa 890F      		add r24,r25
 3994 07ac 9091 0000 		lds r25,voteD
 3995 07b0 890F      		add r24,r25
 3996 07b2 2896      		adiw r28,71-63
 3997 07b4 8FAF      		std Y+63,r24
 3998 07b6 2897      		sbiw r28,71-63
 3999               	.LVL459:
 517:main.c        ****                                 
 4000               		.loc 1 517 0
 4001 07b8 80E0      		ldi r24,lo8(userCount)
 4002 07ba 90E0      		ldi r25,hi8(userCount)
 4003               	.LVL460:
 4004 07bc 0E94 0000 		call eeprom_read_byte
 4005               	.LVL461:
 4006 07c0 682E      		mov r6,r24
 4007               	.LVL462:
 4008 07c2 83E0      		ldi r24,lo8(3)
 4009 07c4 882E      		mov r8,r24
 4010 07c6 912C      		mov r9,__zero_reg__
 4011               	.LVL463:
 4012               	.L164:
 4013               	.LBB558:
 523:main.c        ****                                     LCD_SetPosition(0, 0);
 4014               		.loc 1 523 0
 4015 07c8 0E94 0000 		call LCD_Clear
 4016               	.LVL464:
 4017               	.LBB559:
 4018               	.LBB560:
 883:main.c        **** }
 4019               		.loc 1 883 0
 4020 07cc 80E8      		ldi r24,lo8(-128)
 4021 07ce 0E94 0000 		call LCD_SendCommand
 4022               	.LVL465:
 4023               	.LBE560:
 4024               	.LBE559:
 526:main.c        ****                                     LCD_Print(resultMsg1);
 4025               		.loc 1 526 0
 4026 07d2 8091 0000 		lds r24,voteB
 4027 07d6 1F92      		push __zero_reg__
 4028 07d8 8F93      		push r24
 4029 07da 8091 0000 		lds r24,voteA
 4030 07de 1F92      		push __zero_reg__
 4031 07e0 8F93      		push r24
 4032 07e2 80E0      		ldi r24,lo8(.LC9)
 4033 07e4 90E0      		ldi r25,hi8(.LC9)
 4034 07e6 9F93      		push r25
 4035 07e8 8F93      		push r24
 4036 07ea 1F92      		push __zero_reg__
 4037 07ec 7F92      		push r7
 4038 07ee 1F93      		push r17
 4039 07f0 0F93      		push r16
 4040 07f2 0E94 0000 		call snprintf
 4041               	.LVL466:
 527:main.c        ****                                     LCD_SetPosition(1, 0);
 4042               		.loc 1 527 0
 4043 07f6 C801      		movw r24,r16
 4044 07f8 0E94 0000 		call LCD_Print
 4045               	.LVL467:
 4046               	.LBB561:
 4047               	.LBB562:
 883:main.c        **** }
 4048               		.loc 1 883 0
 4049 07fc 80EC      		ldi r24,lo8(-64)
 4050 07fe 0E94 0000 		call LCD_SendCommand
 4051               	.LVL468:
 4052               	.LBE562:
 4053               	.LBE561:
 530:main.c        ****                                     LCD_Print(resultMsg2);
 4054               		.loc 1 530 0
 4055 0802 8091 0000 		lds r24,voteD
 4056 0806 1F92      		push __zero_reg__
 4057 0808 8F93      		push r24
 4058 080a 8091 0000 		lds r24,voteC
 4059 080e 1F92      		push __zero_reg__
 4060 0810 8F93      		push r24
 4061 0812 20E0      		ldi r18,lo8(.LC10)
 4062 0814 30E0      		ldi r19,hi8(.LC10)
 4063 0816 3F93      		push r19
 4064 0818 2F93      		push r18
 4065 081a 1F92      		push __zero_reg__
 4066 081c 7F92      		push r7
 4067 081e FF92      		push r15
 4068 0820 EF92      		push r14
 4069 0822 0E94 0000 		call snprintf
 4070               	.LVL469:
 531:main.c        ****                                     _delay_ms(1000);
 4071               		.loc 1 531 0
 4072 0826 C701      		movw r24,r14
 4073 0828 0E94 0000 		call LCD_Print
 4074               	.LVL470:
 4075               	.LBB563:
 4076               	.LBB564:
 187:/usr/lib/avr/include/util/delay.h **** 
 4077               		.loc 2 187 0
 4078 082c 9FEF      		ldi r25,lo8(3199999)
 4079 082e E3ED      		ldi r30,hi8(3199999)
 4080 0830 F0E3      		ldi r31,hlo8(3199999)
 4081 0832 9150      	1:	subi r25,1
 4082 0834 E040      		sbci r30,0
 4083 0836 F040      		sbci r31,0
 4084 0838 01F4      		brne 1b
 4085 083a 00C0      		rjmp .
 4086 083c 0000      		nop
 4087               	.LVL471:
 4088               	.LBE564:
 4089               	.LBE563:
 535:main.c        ****                                     LCD_SetPosition(0, 0);
 4090               		.loc 1 535 0
 4091 083e 0E94 0000 		call LCD_Clear
 4092               	.LVL472:
 4093               	.LBB565:
 4094               	.LBB566:
 883:main.c        **** }
 4095               		.loc 1 883 0
 4096 0842 80E8      		ldi r24,lo8(-128)
 4097 0844 0E94 0000 		call LCD_SendCommand
 4098               	.LVL473:
 4099               	.LBE566:
 4100               	.LBE565:
 538:main.c        ****                                     LCD_Print(regMsg);
 4101               		.loc 1 538 0
 4102 0848 1F92      		push __zero_reg__
 4103 084a 6F92      		push r6
 4104 084c 3F92      		push r3
 4105 084e 2F92      		push r2
 4106 0850 1F92      		push __zero_reg__
 4107 0852 7F92      		push r7
 4108 0854 DF92      		push r13
 4109 0856 CF92      		push r12
 4110 0858 0E94 0000 		call snprintf
 4111               	.LVL474:
 539:main.c        ****                                     LCD_SetPosition(1, 0);
 4112               		.loc 1 539 0
 4113 085c C601      		movw r24,r12
 4114 085e 0E94 0000 		call LCD_Print
 4115               	.LVL475:
 4116               	.LBB567:
 4117               	.LBB568:
 883:main.c        **** }
 4118               		.loc 1 883 0
 4119 0862 80EC      		ldi r24,lo8(-64)
 4120 0864 0E94 0000 		call LCD_SendCommand
 4121               	.LVL476:
 4122               	.LBE568:
 4123               	.LBE567:
 542:main.c        ****                                     LCD_Print(votedMsg);
 4124               		.loc 1 542 0
 4125 0868 1F92      		push __zero_reg__
 4126 086a 2896      		adiw r28,71-63
 4127 086c 2FAD      		ldd r18,Y+63
 4128 086e 2897      		sbiw r28,71-63
 4129 0870 2F93      		push r18
 4130 0872 5F92      		push r5
 4131 0874 4F92      		push r4
 4132 0876 1F92      		push __zero_reg__
 4133 0878 7F92      		push r7
 4134 087a BF92      		push r11
 4135 087c AF92      		push r10
 4136 087e 0E94 0000 		call snprintf
 4137               	.LVL477:
 543:main.c        ****                                     _delay_ms(1000);
 4138               		.loc 1 543 0
 4139 0882 0FB6      		in __tmp_reg__,__SREG__
 4140 0884 F894      		cli
 4141 0886 DEBF      		out __SP_H__,r29
 4142 0888 0FBE      		out __SREG__,__tmp_reg__
 4143 088a CDBF      		out __SP_L__,r28
 4144 088c C501      		movw r24,r10
 4145 088e 0E94 0000 		call LCD_Print
 4146               	.LVL478:
 4147               	.LBB569:
 4148               	.LBB570:
 187:/usr/lib/avr/include/util/delay.h **** 
 4149               		.loc 2 187 0
 4150 0892 9FEF      		ldi r25,lo8(3199999)
 4151 0894 E3ED      		ldi r30,hi8(3199999)
 4152 0896 F0E3      		ldi r31,hlo8(3199999)
 4153 0898 9150      	1:	subi r25,1
 4154 089a E040      		sbci r30,0
 4155 089c F040      		sbci r31,0
 4156 089e 01F4      		brne 1b
 4157 08a0 00C0      		rjmp .
 4158 08a2 0000      		nop
 4159               	.LVL479:
 4160 08a4 21E0      		ldi r18,1
 4161 08a6 821A      		sub r8,r18
 4162 08a8 9108      		sbc r9,__zero_reg__
 4163               	.LVL480:
 4164               	.LBE570:
 4165               	.LBE569:
 4166               	.LBE558:
 521:main.c        ****                                     // Display the total votes for 1 second
 4167               		.loc 1 521 0
 4168 08aa 01F0      		breq .+2
 4169 08ac 00C0      		rjmp .L164
 4170 08ae 00C0      		rjmp .L119
 4171               	.LVL481:
 4172               	.L155:
 4173               	.LBE555:
 4174               	.LBE602:
 4175               	.LBB603:
 485:main.c        ****                         LCD_SetPosition(0, 0);
 4176               		.loc 1 485 0
 4177 08b0 0E94 0000 		call LCD_Clear
 4178               	.LVL482:
 4179               	.LBB595:
 4180               	.LBB596:
 883:main.c        **** }
 4181               		.loc 1 883 0
 4182 08b4 80E8      		ldi r24,lo8(-128)
 4183 08b6 0E94 0000 		call LCD_SendCommand
 4184               	.LVL483:
 4185               	.LBE596:
 4186               	.LBE595:
 487:main.c        ****                         blinkLED_Buzzer(LED_PIN_Reg);
 4187               		.loc 1 487 0
 4188 08ba 80E0      		ldi r24,lo8(.LC28)
 4189 08bc 90E0      		ldi r25,hi8(.LC28)
 4190 08be 0E94 0000 		call LCD_Print
 4191               	.LVL484:
 488:main.c        ****                         _delay_ms(100);
 4192               		.loc 1 488 0
 4193 08c2 83E0      		ldi r24,lo8(3)
 4194 08c4 0E94 0000 		call blinkLED_Buzzer
 4195               	.LVL485:
 4196 08c8 00C0      		rjmp .L198
 4197               	.LVL486:
 4198               	.L163:
 4199               	.LBE603:
 4200               	.LBB604:
 554:main.c        ****                                 LCD_SetPosition(0, 0);
 4201               		.loc 1 554 0
 4202 08ca 0E94 0000 		call LCD_Clear
 4203               	.LVL487:
 4204               	.LBB571:
 4205               	.LBB572:
 883:main.c        **** }
 4206               		.loc 1 883 0
 4207 08ce 80E8      		ldi r24,lo8(-128)
 4208 08d0 0E94 0000 		call LCD_SendCommand
 4209               	.LVL488:
 4210               	.LBE572:
 4211               	.LBE571:
 556:main.c        ****                                 blinkLED_Buzzer(LED_PIN_RR);
 4212               		.loc 1 556 0
 4213 08d4 80E0      		ldi r24,lo8(.LC8)
 4214 08d6 90E0      		ldi r25,hi8(.LC8)
 4215 08d8 0E94 0000 		call LCD_Print
 4216               	.LVL489:
 4217               	.LBB573:
 4218               	.LBB574:
 4219 08dc 0E94 0000 		call blinkLED_Buzzer.part.2
 4220               	.LVL490:
 4221               	.LBE574:
 4222               	.LBE573:
 4223               	.LBB575:
 4224               	.LBB548:
 187:/usr/lib/avr/include/util/delay.h **** 
 4225               		.loc 2 187 0
 4226 08e0 3FEF      		ldi r19,lo8(159999)
 4227 08e2 80E7      		ldi r24,hi8(159999)
 4228 08e4 92E0      		ldi r25,hlo8(159999)
 4229 08e6 3150      	1:	subi r19,1
 4230 08e8 8040      		sbci r24,0
 4231 08ea 9040      		sbci r25,0
 4232 08ec 01F4      		brne 1b
 4233 08ee 00C0      		rjmp .L200
 4234               	.LVL491:
 4235               	.L162:
 4236               	.LBE548:
 4237               	.LBE575:
 4238               	.LBB576:
 4239               	.LBB577:
 4240 08f0 EFE3      		ldi r30,lo8(-25537)
 4241 08f2 FCE9      		ldi r31,hi8(-25537)
 4242 08f4 3197      	1:	sbiw r30,1
 4243 08f6 01F4      		brne 1b
 4244 08f8 00C0      		rjmp .
 4245 08fa 0000      		nop
 4246               	.LVL492:
 4247 08fc F1E0      		ldi r31,1
 4248 08fe 8F1A      		sub r8,r31
 4249 0900 9108      		sbc r9,__zero_reg__
 4250               	.LVL493:
 4251               	.LBE577:
 4252               	.LBE576:
 509:main.c        ****                         status = MFRC522_request(0x26, serial);  // Request RFID card scan
 4253               		.loc 1 509 0
 4254 0902 01F0      		breq .+2
 4255 0904 00C0      		rjmp .L166
 4256 0906 00C0      		rjmp .L165
 4257               	.LVL494:
 4258               	.L144:
 4259               	.LBE604:
 4260               	.LBE636:
 4261               	.LBB637:
 4262               	.LBB607:
 187:/usr/lib/avr/include/util/delay.h **** 
 4263               		.loc 2 187 0
 4264 0908 2FEF      		ldi r18,lo8(639999)
 4265 090a 33EC      		ldi r19,hi8(639999)
 4266 090c 89E0      		ldi r24,hlo8(639999)
 4267 090e 2150      	1:	subi r18,1
 4268 0910 3040      		sbci r19,0
 4269 0912 8040      		sbci r24,0
 4270 0914 01F4      		brne 1b
 4271 0916 00C0      		rjmp .L192
 4272               	.LBE607:
 4273               	.LBE637:
 4274               		.cfi_endproc
 4275               	.LFE10:
 4277               		.data
 4280               	previousState.2282:
 4281 0000 01        		.byte	1
 4282               	.global	voteD
 4283               		.section .bss
 4286               	voteD:
 4287 0000 00        		.zero	1
 4288               	.global	voteC
 4291               	voteC:
 4292 0001 00        		.zero	1
 4293               	.global	voteB
 4296               	voteB:
 4297 0002 00        		.zero	1
 4298               	.global	voteA
 4301               	voteA:
 4302 0003 00        		.zero	1
 4303               	.global	votedUsers
 4306               	votedUsers:
 4307 0004 0000 0000 		.zero	20
 4307      0000 0000 
 4307      0000 0000 
 4307      0000 0000 
 4307      0000 0000 
 4308               	.global	storedIDs
 4309               		.section	.eeprom,"aw",@progbits
 4312               	storedIDs:
 4313 0000 0000 0000 		.zero	100
 4313      0000 0000 
 4313      0000 0000 
 4313      0000 0000 
 4313      0000 0000 
 4314               	.global	userCount
 4317               	userCount:
 4318 0064 00        		.zero	1
 4319               	.global	adminID
 4320               		.data
 4323               	adminID:
 4324 0001 A3        		.byte	-93
 4325 0002 9B        		.byte	-101
 4326 0003 42        		.byte	66
 4327 0004 28        		.byte	40
 4328 0005 52        		.byte	82
 4329               		.text
 4330               	.Letext0:
 4331               		.file 3 "/usr/lib/avr/include/stdint.h"
 4332               		.file 4 "/usr/lib/gcc/avr/7.3.0/include/stddef.h"
 4333               		.file 5 "/usr/lib/avr/include/stdlib.h"
 4334               		.file 6 "<built-in>"
 4335               		.file 7 "/usr/lib/avr/include/avr/eeprom.h"
 4336               		.file 8 "/usr/lib/avr/include/string.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccPU1Enz.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccPU1Enz.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccPU1Enz.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccPU1Enz.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccPU1Enz.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccPU1Enz.s:11     .text:0000000000000000 blinkLED_Buzzer.part.2
     /tmp/ccPU1Enz.s:54     .text:000000000000001c initButton
     /tmp/ccPU1Enz.s:86     .text:0000000000000036 initSPI
     /tmp/ccPU1Enz.s:108    .text:0000000000000040 SPI_send
     /tmp/ccPU1Enz.s:132    .text:000000000000004a SPI_receive
     /tmp/ccPU1Enz.s:159    .text:000000000000005a MFRC522_write
     /tmp/ccPU1Enz.s:197    .text:0000000000000074 MFRC522_reset
     /tmp/ccPU1Enz.s:215    .text:000000000000007c MFRC522_read
     /tmp/ccPU1Enz.s:246    .text:0000000000000090 MFRC522_setBitMask
     /tmp/ccPU1Enz.s:287    .text:00000000000000aa MFRC522_clearBitMask
     /tmp/ccPU1Enz.s:330    .text:00000000000000c6 MFRC522_antennaOn
     /tmp/ccPU1Enz.s:364    .text:00000000000000da MFRC522_init
     /tmp/ccPU1Enz.s:413    .text:0000000000000112 MFRC522_toCard
     /tmp/ccPU1Enz.s:710    .text:000000000000025c MFRC522_request
     /tmp/ccPU1Enz.s:801    .text:00000000000002ac MFRC522_anticoll
     /tmp/ccPU1Enz.s:915    .text:0000000000000314 initLEDs_Buzzer
     /tmp/ccPU1Enz.s:935    .text:000000000000031c blinkLED_Buzzer
     /tmp/ccPU1Enz.s:1019   .text:0000000000000364 i2c_init
     /tmp/ccPU1Enz.s:1040   .text:0000000000000370 i2c_start
     /tmp/ccPU1Enz.s:1077   .text:0000000000000392 i2c_stop
     /tmp/ccPU1Enz.s:1101   .text:00000000000003a2 i2c_write
     /tmp/ccPU1Enz.s:1130   .text:00000000000003b6 LCD_SendCommand
     /tmp/ccPU1Enz.s:1207   .text:000000000000040a LCD_Init
     /tmp/ccPU1Enz.s:1307   .text:0000000000000472 LCD_SendData
     /tmp/ccPU1Enz.s:1384   .text:00000000000004c6 LCD_Print
     /tmp/ccPU1Enz.s:1426   .text:00000000000004de LCD_SetPosition
     /tmp/ccPU1Enz.s:1458   .text:00000000000004ee LCD_Clear
     /tmp/ccPU1Enz.s:1494   .text:0000000000000502 LCD_ScrollText
     /tmp/ccPU1Enz.s:1703   .text:00000000000005f0 storeCard
     /tmp/ccPU1Enz.s:4317   .eeprom:0000000000000064 userCount
     /tmp/ccPU1Enz.s:4312   .eeprom:0000000000000000 storedIDs
     /tmp/ccPU1Enz.s:4306   .bss:0000000000000004 votedUsers
     /tmp/ccPU1Enz.s:1773   .text:0000000000000636 getUserIndex
     /tmp/ccPU1Enz.s:1903   .text:00000000000006b6 isRegistered
     /tmp/ccPU1Enz.s:2049   .text:0000000000000748 checkAdmin
     /tmp/ccPU1Enz.s:4323   .data:0000000000000001 adminID
     /tmp/ccPU1Enz.s:2079   .text:0000000000000760 isButtonPressed
     /tmp/ccPU1Enz.s:4280   .data:0000000000000000 previousState.2282
     /tmp/ccPU1Enz.s:2161   .text:00000000000007ac resetEEPROM
     /tmp/ccPU1Enz.s:4301   .bss:0000000000000003 voteA
     /tmp/ccPU1Enz.s:4296   .bss:0000000000000002 voteB
     /tmp/ccPU1Enz.s:4291   .bss:0000000000000001 voteC
     /tmp/ccPU1Enz.s:4286   .bss:0000000000000000 voteD
     /tmp/ccPU1Enz.s:2384   .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
malloc
strcpy
strcat
strncpy
free
eeprom_read_byte
eeprom_write_block
eeprom_write_byte
eeprom_read_block
memcmp
snprintf
__do_copy_data
__do_clear_bss
